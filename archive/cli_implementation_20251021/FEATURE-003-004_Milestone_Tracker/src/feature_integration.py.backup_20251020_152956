from pathlib import Path
import sys
from dataclasses import dataclass
from typing import Optional, Dict, Any, List, Union
from datetime import datetime
import logging

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import layer implementations
from LAYER_001_Date_Calculator.src.implementation import DateCalculator
from LAYER_002_Milestone_Categorizer.src.implementation import MilestoneCategorizer
from LAYER_003_Quadrant_Formatter.src.implementation import (
    QuadrantType, 
    FormatStyle, 
    QuadrantData, 
    FormattedQuadrant, 
    QuadrantFormatterError, 
    InvalidDataError, 
    FormattingError, 
    QuadrantFormatter
)


# Configure logging
logger = logging.getLogger(__name__)


@dataclass
class FeatureConfig:
    """Configuration for the Milestone Tracker feature."""
    date_format: str = "%Y-%m-%d"
    default_format_style: FormatStyle = FormatStyle.STANDARD
    enable_logging: bool = True
    validate_inputs: bool = True


@dataclass
class MilestoneData:
    """Data structure for milestone information."""
    name: str
    start_date: Union[str, datetime]
    end_date: Union[str, datetime]
    category: Optional[str] = None
    description: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None


@dataclass
class FeatureResponse:
    """Unified response structure for feature operations."""
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None


class MilestoneTrackerError(Exception):
    """Base exception for Milestone Tracker feature errors."""
    pass


class LayerInitializationError(MilestoneTrackerError):
    """Raised when a layer fails to initialize."""
    pass


class LayerCommunicationError(MilestoneTrackerError):
    """Raised when communication between layers fails."""
    pass


class FeatureOrchestrator:
    """
    Orchestrates the Milestone Tracker feature by coordinating between
    Date Calculator, Milestone Categorizer, and Quadrant Formatter layers.
    """
    
    def __init__(self, config: Optional[FeatureConfig] = None):
        """
        Initialize the Feature Orchestrator with all required layers.
        
        Args:
            config: Optional configuration for the feature
        
        Raises:
            LayerInitializationError: If any layer fails to initialize
        """
        self.config = config or FeatureConfig()
        
        if self.config.enable_logging:
            logging.basicConfig(level=logging.INFO)
        
        # Initialize layers
        self._initialize_layers()
        
        logger.info("Milestone Tracker Feature initialized successfully")
    
    def _initialize_layers(self) -> None:
        """Initialize all required layers with error handling."""
        try:
            # Initialize Date Calculator
            self.date_calculator = DateCalculator()
            logger.debug("Date Calculator layer initialized")
            
            # Initialize Milestone Categorizer
            self.milestone_categorizer = MilestoneCategorizer()
            logger.debug("Milestone Categorizer layer initialized")
            
            # Initialize Quadrant Formatter
            self.quadrant_formatter = QuadrantFormatter()
            logger.debug("Quadrant Formatter layer initialized")
            
        except Exception as e:
            error_msg = f"Failed to initialize layers: {str(e)}"
            logger.error(error_msg)
            raise LayerInitializationError(error_msg)
    
    def process_milestone(
        self, 
        milestone: MilestoneData,
        format_style: Optional[FormatStyle] = None
    ) -> FeatureResponse:
        """
        Process a single milestone through all layers.
        
        Args:
            milestone: Milestone data to process
            format_style: Optional formatting style for output
        
        Returns:
            FeatureResponse with processed milestone data
        """
        try:
            # Validate input if enabled
            if self.config.validate_inputs:
                self._validate_milestone(milestone)
            
            # Process dates using Date Calculator
            date_info = self._process_dates(milestone)
            
            # Categorize milestone
            category_info = self._categorize_milestone(milestone, date_info)
            
            # Format into quadrant
            formatted_output = self._format_quadrant(
                milestone, 
                date_info, 
                category_info,
                format_style or self.config.default_format_style
            )
            
            return FeatureResponse(
                success=True,
                data=formatted_output,
                metadata={
                    "date_info": date_info,
                    "category_info": category_info,
                    "processing_time": datetime.now().isoformat()
                }
            )
            
        except Exception as e:
            logger.error(f"Error processing milestone: {str(e)}")
            return FeatureResponse(
                success=False,
                error=str(e),
                metadata={"milestone_name": milestone.name}
            )
    
    def process_milestones_batch(
        self, 
        milestones: List[MilestoneData],
        format_style: Optional[FormatStyle] = None
    ) -> FeatureResponse:
        """
        Process multiple milestones as a batch.
        
        Args:
            milestones: List of milestones to process
            format_style: Optional formatting style for output
        
        Returns:
            FeatureResponse with all processed milestones
        """
        try:
            processed_milestones = []
            errors = []
            
            for milestone in milestones:
                result = self.process_milestone(milestone, format_style)
                if result.success:
                    processed_milestones.append({
                        "milestone": milestone.name,
                        "data": result.data,
                        "metadata": result.metadata
                    })
                else:
                    errors.append({
                        "milestone": milestone.name,
                        "error": result.error
                    })
            
            return FeatureResponse(
                success=len(errors) == 0,
                data=processed_milestones,
                error=f"Failed to process {len(errors)} milestones" if errors else None,
                metadata={
                    "total_processed": len(processed_milestones),
                    "total_errors": len(errors),
                    "errors": errors if errors else None
                }
            )
            
        except Exception as e:
            logger.error(f"Error in batch processing: {str(e)}")
            return FeatureResponse(
                success=False,
                error=str(e)
            )
    
    def _validate_milestone(self, milestone: MilestoneData) -> None:
        """
        Validate milestone data.
        
        Args:
            milestone: Milestone data to validate
        
        Raises:
            ValueError: If milestone data is invalid
        """
        if not milestone.name:
            raise ValueError("Milestone name is required")
        
        if not milestone.start_date:
            raise ValueError("Milestone start date is required")
        
        if not milestone.end_date:
            raise ValueError("Milestone end date is required")
    
    def _process_dates(self, milestone: MilestoneData) -> Dict[str, Any]:
        """
        Process milestone dates using Date Calculator layer.
        
        Args:
            milestone: Milestone data containing dates
        
        Returns:
            Dictionary with date calculation results
        """
        try:
            # Convert dates to datetime if they're strings
            start_date = self._ensure_datetime(milestone.start_date)
            end_date = self._ensure_datetime(milestone.end_date)
            
            # Use Date Calculator methods (assuming available methods)
            duration = self.date_calculator.calculate_duration(start_date, end_date)
            days_remaining = self.date_calculator.days_until(end_date)
            progress = self.date_calculator.calculate_progress(start_date, end_date)
            
            return {
                "start_date": start_date,
                "end_date": end_date,
                "duration": duration,
                "days_remaining": days_remaining,
                "progress_percentage": progress
            }
            
        except Exception as e:
            raise LayerCommunicationError(f"Date Calculator error: {str(e)}")
    
    def _categorize_milestone(
        self, 
        milestone: MilestoneData, 
        date_info: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Categorize milestone using Milestone Categorizer layer.
        
        Args:
            milestone: Milestone data
            date_info: Date information from Date Calculator
        
        Returns:
            Dictionary with categorization results
        """
        try:
            # Use Milestone Categorizer methods (assuming available methods)
            category = milestone.category or self.milestone_categorizer.auto_categorize(
                milestone.name,
                date_info["duration"],
                date_info["progress_percentage"]
            )
            
            priority = self.milestone_categorizer.calculate_priority(
                date_info["days_remaining"],
                date_info["progress_percentage"]
            )
            
            status = self.milestone_categorizer.determine_status(
                date_info["progress_percentage"],
                date_info["days_remaining"]
            )
            
            return {
                "category": category,
                "priority": priority,
                "status": status
            }
            
        except Exception as e:
            raise LayerCommunicationError(f"Milestone Categorizer error: {str(e)}")
    
    def _format_quadrant(
        self, 
        milestone: MilestoneData,
        date_info: Dict[str, Any],
        category_info: Dict[str, Any],
        format_style: FormatStyle
    ) -> FormattedQuadrant:
        """
        Format milestone data into quadrant using Quadrant Formatter layer.
        
        Args:
            milestone: Original milestone data
            date_info: Date calculation results
            category_info: Categorization results
            format_style: Style for formatting
        
        Returns:
            Formatted quadrant output
        """
        try:
            # Determine quadrant type based on priority and status
            quadrant_type = self._determine_quadrant_type(category_info)
            
            # Create QuadrantData
            quadrant_data = QuadrantData(
                title=milestone.name,
                description=milestone.description or "",
                items=[
                    f"Duration: {date_info['duration']} days",
                    f"Progress: {date_info['progress_percentage']:.1f}%",
                    f"Status: {category_info['status']}",
                    f"Priority: {category_info['priority']}"
                ],
                metadata={
                    **(milestone.metadata if milestone.metadata else {}),
                    "category": category_info["category"],
                    "days_remaining": date_info["days_remaining"]
                }
            )
            
            # Format using Quadrant Formatter
            formatted = self.quadrant_formatter.format_quadrant(
                quadrant_type,
                quadrant_data,
                format_style
            )
            
            return formatted
            
        except (QuadrantFormatterError, InvalidDataError, FormattingError) as e:
            raise LayerCommunicationError(f"Quadrant Formatter error: {str(e)}")
    
    def _determine_quadrant_type(self, category_info: Dict[str, Any]) -> QuadrantType:
        """
        Determine the appropriate quadrant type based on categorization.
        
        Args:
            category_info: Categorization results
        
        Returns:
            Appropriate QuadrantType
        """
        priority = category_info.get("priority", "").lower()
        status = category_info.get("status", "").lower()
        
        if priority == "urgent" and status == "at_risk":
            return QuadrantType.URGENT_IMPORTANT
        elif priority == "high":
            return QuadrantType.NOT_URGENT_IMPORTANT
        elif status == "on_track":
            return QuadrantType.NOT_URGENT_NOT_IMPORTANT
        else:
            return QuadrantType.URGENT_NOT_IMPORTANT
    
    def _ensure_datetime(self, date_value: Union[str, datetime]) -> datetime:
        """
        Ensure date value is a datetime object.
        
        Args:
            date_value: Date as string or datetime
        
        Returns:
            datetime object
        """
        if isinstance(date_value, datetime):
            return date_value
        elif isinstance(date_value, str):
            return datetime.strptime(date_value, self.config.date_format)
        else:
            raise ValueError(f"Invalid date type: {type(date_value)}")
    
    def get_layer_status(self) -> FeatureResponse:
        """
        Get the status of all layers.
        
        Returns:
            FeatureResponse with layer status information
        """
        try:
            status = {
                "date_calculator": {
                    "initialized": hasattr(self, 'date_calculator'),
                    "class": self.date_calculator.__class__.__name__ if hasattr(self, 'date_calculator') else None
                },
                "milestone_categorizer": {
                    "initialized": hasattr(self, 'milestone_categorizer'),
                    "class": self.milestone_categorizer.__class__.__name__ if hasattr(self, 'milestone_categorizer') else None
                },
                "quadrant_formatter": {
                    "initialized": hasattr(self, 'quadrant_formatter'),
                    "class": self.quadrant_formatter.__class__.__name__ if hasattr(self, 'quadrant_formatter') else None
                }
            }
            
            return FeatureResponse(
                success=True,
                data=status,
                metadata={"timestamp": datetime.now().isoformat()}
            )
            
        except Exception as e:
            return FeatureResponse(
                success=False,
                error=str(e)
            )