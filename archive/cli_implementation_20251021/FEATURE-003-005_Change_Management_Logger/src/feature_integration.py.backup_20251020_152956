"""
Feature Integration Module for Change Management Logger
FEATURE ID: FEATURE-003-005

This module orchestrates the integration of all layers:
- Terminal UI (LAYER-001)
- Change Data Collector (LAYER-002)
- Log File Writer (LAYER-003)
"""

from pathlib import Path
import sys
from dataclasses import dataclass
from typing import Optional, Dict, Any, List
from datetime import datetime
import logging

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import layer implementations
from LAYER_001_Terminal_UI.src.implementation import (
    ValidationError,
    ChangeManagementError,
    ChangeValidator,
    ChangeLogger as UIChangeLogger,
    TerminalUI
)
from LAYER_002_Change_Data_Collector.src.implementation import ChangeDataCollector
from LAYER_003_Log_File_Writer.src.implementation import (
    LogFileWriter,
    ChangeLogger as FileChangeLogger
)


@dataclass
class FeatureConfig:
    """Configuration for the Change Management Logger feature."""
    log_directory: str = "./logs"
    log_file_prefix: str = "change_management"
    enable_terminal_ui: bool = True
    validation_enabled: bool = True
    auto_save: bool = True
    max_log_size_mb: int = 100
    retention_days: int = 90


@dataclass
class FeatureResponse:
    """Unified response structure for feature operations."""
    success: bool
    message: str
    data: Optional[Dict[str, Any]] = None
    errors: Optional[List[str]] = None
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


class FeatureOrchestrator:
    """
    Main orchestrator for the Change Management Logger feature.
    
    This class coordinates all layers to provide a cohesive change
    management logging system with terminal UI, data collection,
    and file persistence capabilities.
    """
    
    def __init__(self, config: Optional[FeatureConfig] = None):
        """
        Initialize the Feature Orchestrator with all required layers.
        
        Args:
            config: Optional configuration object. Uses defaults if not provided.
        """
        self.config = config or FeatureConfig()
        self.logger = logging.getLogger(__name__)
        
        # Initialize layer instances
        self._terminal_ui: Optional[TerminalUI] = None
        self._change_validator: Optional[ChangeValidator] = None
        self._ui_change_logger: Optional[UIChangeLogger] = None
        self._data_collector: Optional[ChangeDataCollector] = None
        self._log_writer: Optional[LogFileWriter] = None
        self._file_change_logger: Optional[FileChangeLogger] = None
        
        # Initialize all layers
        self._initialize_layers()
    
    def _initialize_layers(self) -> None:
        """Initialize all layer components with proper error handling."""
        try:
            # Initialize Terminal UI layer
            if self.config.enable_terminal_ui:
                self._terminal_ui = TerminalUI()
                self._change_validator = ChangeValidator()
                self._ui_change_logger = UIChangeLogger()
            
            # Initialize Data Collector layer
            self._data_collector = ChangeDataCollector()
            
            # Initialize Log File Writer layer
            self._log_writer = LogFileWriter(
                log_directory=self.config.log_directory,
                max_buffer_size=100
            )
            self._file_change_logger = FileChangeLogger()
            
            self.logger.info("All layers initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize layers: {str(e)}")
            raise ChangeManagementError(f"Layer initialization failed: {str(e)}")
    
    def log_change(self, change_data: Dict[str, Any]) -> FeatureResponse:
        """
        Log a change through all layers of the system.
        
        Args:
            change_data: Dictionary containing change information
            
        Returns:
            FeatureResponse with operation status and details
        """
        errors = []
        
        try:
            # Validate change data if enabled
            if self.config.validation_enabled and self._change_validator:
                try:
                    self._change_validator.validate(change_data)
                except ValidationError as ve:
                    return FeatureResponse(
                        success=False,
                        message="Validation failed",
                        errors=[str(ve)]
                    )
            
            # Collect additional change data
            enriched_data = self._collect_change_data(change_data)
            
            # Display in terminal UI if enabled
            if self.config.enable_terminal_ui and self._terminal_ui:
                self._terminal_ui.display_change(enriched_data)
            
            # Write to log file
            log_result = self._write_to_log(enriched_data)
            
            if not log_result:
                errors.append("Failed to write to log file")
            
            # Auto-save if enabled
            if self.config.auto_save and self._log_writer:
                self._log_writer.save()
            
            return FeatureResponse(
                success=len(errors) == 0,
                message="Change logged successfully" if not errors else "Change logged with errors",
                data=enriched_data,
                errors=errors if errors else None
            )
            
        except Exception as e:
            self.logger.error(f"Error logging change: {str(e)}")
            return FeatureResponse(
                success=False,
                message="Failed to log change",
                errors=[str(e)]
            )
    
    def _collect_change_data(self, initial_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Collect and enrich change data using the data collector layer.
        
        Args:
            initial_data: Initial change data
            
        Returns:
            Enriched change data dictionary
        """
        if self._data_collector:
            try:
                # Collect system information
                system_info = self._data_collector.collect_system_info()
                
                # Collect user information
                user_info = self._data_collector.collect_user_info()
                
                # Combine all data
                enriched_data = {
                    **initial_data,
                    "system_info": system_info,
                    "user_info": user_info,
                    "timestamp": datetime.now().isoformat()
                }
                
                return enriched_data
                
            except Exception as e:
                self.logger.warning(f"Error collecting additional data: {str(e)}")
                return initial_data
        
        return initial_data
    
    def _write_to_log(self, change_data: Dict[str, Any]) -> bool:
        """
        Write change data to log file using the log writer layer.
        
        Args:
            change_data: Change data to write
            
        Returns:
            Success status
        """
        if self._log_writer:
            try:
                # Format the log entry
                log_entry = self._file_change_logger.format_log_entry(change_data)
                
                # Write to file
                self._log_writer.write_entry(log_entry)
                
                return True
                
            except Exception as e:
                self.logger.error(f"Error writing to log: {str(e)}")
                return False
        
        return False
    
    def view_change_history(self, filters: Optional[Dict[str, Any]] = None) -> FeatureResponse:
        """
        View change history with optional filters.
        
        Args:
            filters: Optional filters for change history
            
        Returns:
            FeatureResponse with change history data
        """
        try:
            if self._log_writer:
                history = self._log_writer.read_history(filters)
                
                # Display in terminal UI if enabled
                if self.config.enable_terminal_ui and self._terminal_ui:
                    self._terminal_ui.display_history(history)
                
                return FeatureResponse(
                    success=True,
                    message=f"Retrieved {len(history)} change records",
                    data={"history": history}
                )
            
            return FeatureResponse(
                success=False,
                message="Log writer not available"
            )
            
        except Exception as e:
            self.logger.error(f"Error viewing history: {str(e)}")
            return FeatureResponse(
                success=False,
                message="Failed to retrieve change history",
                errors=[str(e)]
            )
    
    def rotate_logs(self) -> FeatureResponse:
        """
        Rotate log files based on size and retention policy.
        
        Returns:
            FeatureResponse with rotation status
        """
        try:
            if self._log_writer:
                rotation_result = self._log_writer.rotate_logs(
                    max_size_mb=self.config.max_log_size_mb,
                    retention_days=self.config.retention_days
                )
                
                return FeatureResponse(
                    success=True,
                    message="Log rotation completed",
                    data=rotation_result
                )
            
            return FeatureResponse(
                success=False,
                message="Log writer not available"
            )
            
        except Exception as e:
            self.logger.error(f"Error rotating logs: {str(e)}")
            return FeatureResponse(
                success=False,
                message="Failed to rotate logs",
                errors=[str(e)]
            )
    
    def get_statistics(self) -> FeatureResponse:
        """
        Get statistics about logged changes.
        
        Returns:
            FeatureResponse with statistics data
        """
        try:
            stats = {}
            
            # Get data collector statistics
            if self._data_collector:
                stats["collector_stats"] = self._data_collector.get_statistics()
            
            # Get log writer statistics
            if self._log_writer:
                stats["writer_stats"] = self._log_writer.get_statistics()
            
            # Get UI logger statistics
            if self._ui_change_logger:
                stats["ui_stats"] = self._ui_change_logger.get_statistics()
            
            return FeatureResponse(
                success=True,
                message="Statistics retrieved successfully",
                data=stats
            )
            
        except Exception as e:
            self.logger.error(f"Error getting statistics: {str(e)}")
            return FeatureResponse(
                success=False,
                message="Failed to retrieve statistics",
                errors=[str(e)]
            )
    
    def cleanup(self) -> FeatureResponse:
        """
        Perform cleanup operations for all layers.
        
        Returns:
            FeatureResponse with cleanup status
        """
        try:
            cleanup_results = []
            
            # Cleanup Terminal UI
            if self._terminal_ui:
                self._terminal_ui.cleanup()
                cleanup_results.append("Terminal UI cleaned up")
            
            # Cleanup Data Collector
            if self._data_collector:
                self._data_collector.cleanup()
                cleanup_results.append("Data Collector cleaned up")
            
            # Cleanup Log Writer
            if self._log_writer:
                self._log_writer.cleanup()
                cleanup_results.append("Log Writer cleaned up")
            
            return FeatureResponse(
                success=True,
                message="Cleanup completed successfully",
                data={"cleanup_results": cleanup_results}
            )
            
        except Exception as e:
            self.logger.error(f"Error during cleanup: {str(e)}")
            return FeatureResponse(
                success=False,
                message="Cleanup failed",
                errors=[str(e)]
            )


def create_orchestrator(config: Optional[FeatureConfig] = None) -> FeatureOrchestrator:
    """
    Factory function to create a configured FeatureOrchestrator instance.
    
    Args:
        config: Optional configuration object
        
    Returns:
        Configured FeatureOrchestrator instance
    """
    return FeatureOrchestrator(config)


# Example usage
if __name__ == "__main__":
    # Create orchestrator with default configuration
    orchestrator = create_orchestrator()
    
    # Example change data
    change_data = {
        "change_id": "CHG-001",
        "description": "Updated report generation parameters",
        "change_type": "configuration",
        "affected_components": ["report_generator", "data_processor"],
        "risk_level": "medium"
    }
    
    # Log the change
    response = orchestrator.log_change(change_data)
    print(f"Change logged: {response.success} - {response.message}")
    
    # View history
    history_response = orchestrator.view_change_history()
    print(f"History retrieved: {history_response.success}")
    
    # Cleanup
    cleanup_response = orchestrator.cleanup()
    print(f"Cleanup completed: {cleanup_response.success}")