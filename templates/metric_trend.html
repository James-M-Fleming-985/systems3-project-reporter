{% extends "base.html" %}

{% block title %}{{ metric_name }} - Trend Chart{% endblock %}

{% block content %}
<div class="bg-white rounded-lg shadow-lg p-8">
    <div class="mb-6">
        <h2 class="text-3xl font-bold text-gray-800 mb-2">{{ metric_name }}</h2>
        <p class="text-gray-600">{{ project_name }} - Trend Analysis</p>
    </div>
    
    <div id="metricTrendChart" style="width:100%; height:600px;"></div>
    
    <div id="noDataMessage" class="hidden text-center py-12">
        <svg class="mx-auto h-16 w-16 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
        </svg>
        <p class="text-gray-500 text-lg">No historical data available for this metric</p>
    </div>
</div>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
const metricName = "{{ metric_name }}";
const projectName = "{{ project_name }}";

console.log('=== METRIC TREND PAGE DEBUG ===');
console.log('Looking for metric:', metricName);
console.log('Project name from server:', projectName);

// List all localStorage keys to help debug
console.log('All localStorage keys:');
for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key.startsWith('customMetrics_')) {
        console.log('  -', key);
    }
}

// Load custom metrics from localStorage
// Try selectedProgram first (matches upload page), then project name from server
const selectedProgram = localStorage.getItem('selectedProgram');
console.log('selectedProgram from localStorage:', selectedProgram);

let storageKey = selectedProgram ? `customMetrics_${selectedProgram}` : `customMetrics_${projectName}`;
console.log('Trying storage key:', storageKey);
let stored = localStorage.getItem(storageKey);

// If not found, try the other option
if (!stored && selectedProgram) {
    console.log('Not found, trying project name:', projectName);
    storageKey = `customMetrics_${projectName}`;
    stored = localStorage.getItem(storageKey);
}

// If still not found, try without extension
if (!stored) {
    const programNameWithoutExt = selectedProgram ? selectedProgram.replace('.xml', '') : projectName.replace('.xml', '');
    storageKey = `customMetrics_${programNameWithoutExt}`;
    console.log('Trying without extension:', storageKey);
    stored = localStorage.getItem(storageKey);
}

console.log('Storage key used:', storageKey);
console.log('Stored data found:', !!stored);

if (!stored) {
    document.getElementById('noDataMessage').classList.remove('hidden');
    document.getElementById('metricTrendChart').style.display = 'none';
} else {
    try {
        const customMetrics = JSON.parse(stored);
        console.log('Total metrics found:', customMetrics.length);
        const metric = customMetrics.find(m => m.name === metricName);
        console.log('Looking for metric:', metricName);
        console.log('Found metric:', metric ? metric.name : 'NOT FOUND');
        
        if (!metric) {
            document.getElementById('noDataMessage').classList.remove('hidden');
            document.getElementById('metricTrendChart').style.display = 'none';
        } else {
            // Check if metric has data (either series or legacy history)
            const hasSeries = metric.series && Object.keys(metric.series).length > 0;
            const hasHistory = metric.history && metric.history.length > 0;
            
            if (!hasSeries && !hasHistory) {
                document.getElementById('noDataMessage').classList.remove('hidden');
                document.getElementById('metricTrendChart').style.display = 'none';
            } else {
                // Render the trend chart
                renderTrendChart(metric);
            }
        }
    } catch (e) {
        console.error('Failed to parse metrics:', e);
        document.getElementById('noDataMessage').classList.remove('hidden');
        document.getElementById('metricTrendChart').style.display = 'none';
    }
}

function renderTrendChart(metric) {
    console.log('Rendering chart for metric:', metric.name);
    console.log('Metric series:', metric.series);
    console.log('Series keys:', metric.series ? Object.keys(metric.series) : 'none');
    console.log('Metric history:', metric.history);
    console.log('History length:', metric.history ? metric.history.length : 0);
    
    const colors = ['#3b82f6', '#ef4444', '#22c55e', '#f59e0b', '#8b5cf6', '#ec4899'];
    const data = [];
    const allDates = new Set();
    
    // Check if metric has multiple series or single history
    if (metric.series && Object.keys(metric.series).length > 0) {
        // Multiple series - render multiple lines
        console.log('âœ… Rendering multiple series:', Object.keys(metric.series).length);
        Object.keys(metric.series).forEach((seriesName, idx) => {
            const seriesData = metric.series[seriesName];
            console.log(`Series "${seriesName}":`, seriesData.length, 'data points');
            const sortedHistory = [...seriesData].sort((a, b) => new Date(a.date) - new Date(b.date));
            const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
            const values = sortedHistory.map(h => h.value);
            
            console.log(`  Dates:`, dates);
            console.log(`  Values:`, values);
            
            // Collect all unique dates
            dates.forEach(d => allDates.add(d));
            
            const color = colors[idx % colors.length];
            data.push({
                x: dates,
                y: values,
                type: 'scatter',
                mode: 'lines+markers',
                name: seriesName,
                line: { 
                    color: color, 
                    width: 3 
                },
                marker: { 
                    size: 10,
                    color: color,
                    line: {
                        color: 'white',
                        width: 2
                    }
                },
                text: sortedHistory.map(h => h.annotation || ''),
                hovertemplate: '<b>%{y}' + (metric.unit ? ' ' + metric.unit : '') + '</b><br>%{x}<br>%{text}<extra></extra>'
            });
        });
    } else if (metric.history && metric.history.length > 0) {
        // Single series (legacy) - render single line
        console.log('âœ… Rendering legacy history with', metric.history.length, 'data points');
        const sortedHistory = [...metric.history].sort((a, b) => new Date(a.date) - new Date(b.date));
        const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
        const values = sortedHistory.map(h => h.value);
        
        console.log('History dates:', dates);
        console.log('History values:', values);
        
        dates.forEach(d => allDates.add(d));
        
        data.push({
            x: dates,
            y: values,
            type: 'scatter',
            mode: 'lines+markers',
            name: metric.name,
            line: { 
                color: '#3b82f6', 
                width: 4 
            },
            marker: { 
                size: 12,
                color: '#3b82f6',
                line: {
                    color: '#1e40af',
                    width: 2
                }
            },
            text: sortedHistory.map(h => h.annotation || ''),
            hovertemplate: '<b>%{y}' + (metric.unit ? ' ' + metric.unit : '') + '</b><br>%{x}<br>%{text}<extra></extra>'
        });
    } else {
        console.error('âŒ No series or history data found for metric');
    }
    
    console.log('ðŸ“Š Total data traces to plot:', data.length);
    
    if (data.length === 0) {
        console.error('âŒ No data to plot - showing no data message');
        document.getElementById('noDataMessage').classList.remove('hidden');
        document.getElementById('metricTrendChart').style.display = 'none';
        return;
    }
    
    const sortedDates = Array.from(allDates).sort((a, b) => new Date(a) - new Date(b));
    
    const layout = {
        title: {
            text: `${metric.name} Trend`,
            font: { size: 24, color: '#1f2937', weight: 'bold' }
        },
        yaxis: { 
            title: {
                text: metric.unit ? `Value (${metric.unit})` : 'Value',
                font: { size: 16 }
            },
            zeroline: false,
            gridcolor: '#e5e7eb',
            font: { size: 14 }
        },
        xaxis: { 
            title: {
                text: 'Date',
                font: { size: 16 }
            },
            tickangle: -45,
            automargin: true,
            gridcolor: '#e5e7eb',
            font: { size: 14 }
        },
        margin: { t: 80, b: 120, l: 80, r: 60 },
        paper_bgcolor: '#ffffff',
        plot_bgcolor: '#f9fafb',
        shapes: [],
        annotations: []
    };
    
    // Add target line if defined
    if (metric.target && sortedDates.length > 0) {
        layout.shapes.push({
            type: 'line',
            x0: sortedDates[0],
            y0: metric.target,
            x1: sortedDates[sortedDates.length - 1],
            y1: metric.target,
            line: {
                color: '#22c55e',
                width: 3,
                dash: 'dash'
            }
        });
        
        // Add target label
        layout.annotations.push({
            x: sortedDates[Math.floor(sortedDates.length / 2)],
            y: metric.target,
            text: `Target: ${metric.target}${metric.unit ? ' ' + metric.unit : ''}`,
            showarrow: false,
            yshift: 20,
            font: { size: 14, color: '#22c55e', weight: 'bold' },
            bgcolor: 'rgba(255, 255, 255, 0.95)',
            bordercolor: '#22c55e',
            borderwidth: 2,
            borderpad: 6
        });
    }
    
    // Add annotations for data points with callouts (only for single series to avoid clutter)
    if (metric.history && metric.history.length > 0 && (!metric.series || Object.keys(metric.series).length === 0)) {
        const sortedHistory = [...metric.history].sort((a, b) => new Date(a.date) - new Date(b.date));
        const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
        const values = sortedHistory.map(h => h.value);
        
        // Add current value annotation for single series
        const lastValue = values[values.length - 1];
        const lastDate = dates[dates.length - 1];
        layout.annotations.push({
            x: lastDate,
            y: lastValue,
            text: `Current: ${lastValue}${metric.unit ? ' ' + metric.unit : ''}`,
            showarrow: true,
            arrowhead: 2,
            arrowsize: 1,
            arrowcolor: '#3b82f6',
            ax: 40,
            ay: -40,
            font: { size: 14, color: '#1e40af', weight: 'bold' },
            bgcolor: 'rgba(255, 255, 255, 0.95)',
            bordercolor: '#3b82f6',
            borderwidth: 2,
            borderpad: 6
        });
        
        const annotatedPoints = sortedHistory
            .map((h, i) => ({ ...h, index: i, date: dates[i], value: values[i] }))
            .filter(h => h.annotation);
        
        annotatedPoints.forEach((point, idx) => {
            const yshift = 50 + (idx % 3) * 25;
            const ax = idx % 2 === 0 ? -60 : 60;
            const align = ax < 0 ? 'right' : 'left';
            
            layout.annotations.push({
                x: point.date,
                y: point.value,
                text: point.annotation,
                showarrow: true,
                arrowhead: 2,
                arrowsize: 1,
                arrowcolor: '#9ca3af',
                ax: ax,
                ay: -yshift,
                font: { size: 13, color: '#374151' },
                bgcolor: 'rgba(255, 255, 255, 0.98)',
                bordercolor: '#d1d5db',
                borderwidth: 1,
                borderpad: 6,
                align: align
            });
        });
    }
    
    const config = {
        responsive: true,
        displayModeBar: false
    };
    
    Plotly.newPlot('metricTrendChart', data, layout, config);
}
</script>
{% endblock %}
