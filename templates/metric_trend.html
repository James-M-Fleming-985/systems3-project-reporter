{% extends "base.html" %}

{% block title %}{{ metric_name }} - Trend Chart{% endblock %}

{% block content %}
<div class="bg-white rounded-lg shadow-lg p-8">
    <div class="mb-6">
        <h2 class="text-3xl font-bold text-gray-800 mb-2">{{ metric_name }}</h2>
        <p class="text-gray-600">{{ project_name }} - Trend Analysis</p>
    </div>
    
    <div id="metricTrendChart" style="width:100%; height:600px;"></div>
    
    <div id="noDataMessage" class="hidden text-center py-12">
        <svg class="mx-auto h-16 w-16 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
        </svg>
        <p class="text-gray-500 text-lg">No historical data available for this metric</p>
    </div>
</div>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
const metricName = "{{ metric_name }}";
const projectName = "{{ project_name }}";

// Check if metric data was passed from server (for screenshot capture)
const serverMetricData = {{ metric_data|tojson if metric_data else 'null' }};

console.log('=== METRIC TREND PAGE DEBUG ===');
console.log('Looking for metric:', metricName);
console.log('Project name from server:', projectName);
console.log('Server-provided metric data:', serverMetricData ? 'YES' : 'NO');

let metric = serverMetricData;

// If no server data, try localStorage (for regular page views)
if (!metric) {
    console.log('No server data, checking localStorage...');
    
    // List all localStorage keys to help debug
    console.log('All localStorage keys:');
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('customMetrics_')) {
            console.log('  -', key);
        }
    }

    // Load custom metrics from localStorage
    const selectedProgram = localStorage.getItem('selectedProgram');
    console.log('selectedProgram from localStorage:', selectedProgram);

    let storageKey = selectedProgram ? `customMetrics_${selectedProgram}` : `customMetrics_${projectName}`;
    console.log('Trying storage key:', storageKey);
    let stored = localStorage.getItem(storageKey);

    // If not found, try the other option
    if (!stored && selectedProgram) {
        console.log('Not found, trying project name:', projectName);
        storageKey = `customMetrics_${projectName}`;
        stored = localStorage.getItem(storageKey);
    }

    // If still not found, try without extension
    if (!stored) {
        const programNameWithoutExt = selectedProgram ? selectedProgram.replace('.xml', '') : projectName.replace('.xml', '');
        storageKey = `customMetrics_${programNameWithoutExt}`;
        console.log('Trying without extension:', storageKey);
        stored = localStorage.getItem(storageKey);
    }

    console.log('Storage key used:', storageKey);
    console.log('Stored data found:', !!stored);

    if (stored) {
        try {
            const customMetrics = JSON.parse(stored);
            console.log('Total metrics found:', customMetrics.length);
            metric = customMetrics.find(m => m.name === metricName);
            console.log('Found metric:', metric ? metric.name : 'NOT FOUND');
        } catch (e) {
            console.error('Failed to parse metrics:', e);
        }
    }
}

// Check if we have metric data (from server or localStorage)
if (!metric) {
    console.log('âŒ No metric data available');
    document.getElementById('noDataMessage').classList.remove('hidden');
    document.getElementById('metricTrendChart').style.display = 'none';
} else {
    // Check if metric has data (either series or legacy history)
    const hasSeries = metric.series && Object.keys(metric.series).length > 0;
    const hasHistory = metric.history && metric.history.length > 0;
    
    if (!hasSeries && !hasHistory) {
        console.log('âŒ Metric found but no data');
        document.getElementById('noDataMessage').classList.remove('hidden');
        document.getElementById('metricTrendChart').style.display = 'none';
    } else {
        console.log('âœ… Rendering chart with data from:', serverMetricData ? 'SERVER' : 'LOCALSTORAGE');
        // Render the trend chart
        renderTrendChart(metric);
    }
}

function renderTrendChart(metric) {
    console.log('Rendering chart for metric:', metric.name);
    console.log('Metric series:', metric.series);
    console.log('Series keys:', metric.series ? Object.keys(metric.series) : 'none');
    console.log('Metric history:', metric.history);
    console.log('History length:', metric.history ? metric.history.length : 0);
    
    const colors = ['#3b82f6', '#ef4444', '#22c55e', '#f59e0b', '#8b5cf6', '#ec4899'];
    const data = [];
    const allDates = new Set();
    
    // Check if metric has multiple series or single history
    if (metric.series && Object.keys(metric.series).length > 0) {
        // Multiple series - render multiple lines
        console.log('âœ… Rendering multiple series:', Object.keys(metric.series).length);
        Object.keys(metric.series).forEach((seriesName, idx) => {
            const seriesData = metric.series[seriesName];
            console.log(`Series "${seriesName}":`, seriesData.length, 'data points');
            const sortedHistory = [...seriesData].sort((a, b) => new Date(a.date) - new Date(b.date));
            const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
            const values = sortedHistory.map(h => h.value);
            
            console.log(`  Dates:`, dates);
            console.log(`  Values:`, values);
            
            // Collect all unique dates
            dates.forEach(d => allDates.add(d));
            
            const color = colors[idx % colors.length];
            const trace = {
                x: dates,
                y: values,
                type: 'scatter',
                mode: 'lines+markers',
                name: seriesName,
                line: { 
                    color: color, 
                    width: 3 
                },
                marker: { 
                    size: 10,
                    color: color,
                    line: {
                        color: 'white',
                        width: 2
                    }
                },
                text: sortedHistory.map(h => h.annotation || ''),
                hovertemplate: '<b>%{y}' + (metric.unit ? ' ' + metric.unit : '') + '</b><br>%{x}<br>%{text}<extra></extra>'
            };
            
            // Assign to yaxis2 if this series should use the right axis
            if (yaxis2SeriesNames.includes(seriesName)) {
                trace.yaxis = 'y2';
            }
            
            data.push(trace);
        });
    } else if (metric.history && metric.history.length > 0) {
        // Single series (legacy) - render single line
        console.log('âœ… Rendering legacy history with', metric.history.length, 'data points');
        const sortedHistory = [...metric.history].sort((a, b) => new Date(a.date) - new Date(b.date));
        const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
        const values = sortedHistory.map(h => h.value);
        
        console.log('History dates:', dates);
        console.log('History values:', values);
        
        dates.forEach(d => allDates.add(d));
        
        data.push({
            x: dates,
            y: values,
            type: 'scatter',
            mode: 'lines+markers',
            name: metric.name,
            line: { 
                color: '#3b82f6', 
                width: 4 
            },
            marker: { 
                size: 12,
                color: '#3b82f6',
                line: {
                    color: '#1e40af',
                    width: 2
                }
            },
            text: sortedHistory.map(h => h.annotation || ''),
            hovertemplate: '<b>%{y}' + (metric.unit ? ' ' + metric.unit : '') + '</b><br>%{x}<br>%{text}<extra></extra>'
        });
    } else {
        console.error('âŒ No series or history data found for metric');
    }
    
    console.log('ðŸ“Š Total data traces to plot:', data.length);
    
    if (data.length === 0) {
        console.error('âŒ No data to plot - showing no data message');
        document.getElementById('noDataMessage').classList.remove('hidden');
        document.getElementById('metricTrendChart').style.display = 'none';
        return;
    }
    
    const sortedDates = Array.from(allDates).sort((a, b) => new Date(a) - new Date(b));
    
    // Detect if we need dual Y-axes (different value ranges across series)
    let needsDualAxis = false;
    let yaxis2SeriesNames = [];
    
    if (metric.series && Object.keys(metric.series).length > 1) {
        const seriesKeys = Object.keys(metric.series);
        const ranges = {};
        
        // Calculate range for each series
        seriesKeys.forEach(key => {
            const values = metric.series[key].map(h => h.value);
            const min = Math.min(...values);
            const max = Math.max(...values);
            ranges[key] = { min, max, range: max - min };
        });
        
        // Check if any series has drastically different scale (e.g., 0-100 vs 0-1000)
        const rangeValues = Object.values(ranges).map(r => r.range);
        const maxRange = Math.max(...rangeValues);
        const minRange = Math.min(...rangeValues.filter(r => r > 0));
        
        // If range difference is > 10x, use dual axis
        if (maxRange / minRange > 10) {
            needsDualAxis = true;
            // Put the smaller-range series on the right axis
            const smallRangeSeries = Object.keys(ranges).find(k => ranges[k].range === minRange);
            yaxis2SeriesNames.push(smallRangeSeries);
            console.log(`ðŸ“Š Dual Y-axis enabled: "${smallRangeSeries}" on right axis`);;
        }
    }
    
    const layout = {
        title: {
            text: `${metric.name} Trend`,
            font: { size: 24, color: '#1f2937', weight: 'bold' }
        },
        yaxis: { 
            title: {
                text: metric.unit ? `Value (${metric.unit})` : 'Value',
                font: { size: 16 }
            },
            zeroline: false,
            gridcolor: '#e5e7eb',
            font: { size: 14 }
        },
        xaxis: { 
            title: {
                text: 'Date',
                font: { size: 16 }
            },
            tickangle: -45,
            automargin: true,
            gridcolor: '#e5e7eb',
            font: { size: 14 }
        },
        margin: { t: 80, b: 120, l: 80, r: 80 },  // Increased right margin for yaxis2
        paper_bgcolor: '#ffffff',
        plot_bgcolor: '#f9fafb',
        shapes: [],
        annotations: []
    };
    
    // Add secondary Y-axis if needed
    if (needsDualAxis) {
        layout.yaxis2 = {
            title: {
                text: 'Percentage (%)',
                font: { size: 16 }
            },
            overlaying: 'y',
            side: 'right',
            zeroline: false,
            gridcolor: 'transparent',  // Don't show gridlines for secondary axis
            font: { size: 14 }
        };
    }
    
    // Add target line if defined
    if (metric.target && sortedDates.length > 0) {
        layout.shapes.push({
            type: 'line',
            x0: sortedDates[0],
            y0: metric.target,
            x1: sortedDates[sortedDates.length - 1],
            y1: metric.target,
            line: {
                color: '#22c55e',
                width: 3,
                dash: 'dash'
            }
        });
        
        // Add target label
        layout.annotations.push({
            x: sortedDates[Math.floor(sortedDates.length / 2)],
            y: metric.target,
            text: `Target: ${metric.target}${metric.unit ? ' ' + metric.unit : ''}`,
            showarrow: false,
            yshift: 20,
            font: { size: 14, color: '#22c55e', weight: 'bold' },
            bgcolor: 'rgba(255, 255, 255, 0.95)',
            bordercolor: '#22c55e',
            borderwidth: 2,
            borderpad: 6
        });
    }
    
    // Add annotations for data points with callouts
    // For multi-series metrics
    if (metric.series && Object.keys(metric.series).length > 0) {
        let annotationIdx = 0;
        Object.keys(metric.series).forEach((seriesName, seriesIdx) => {
            const seriesData = metric.series[seriesName];
            const sortedHistory = [...seriesData].sort((a, b) => new Date(a.date) - new Date(b.date));
            const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
            const values = sortedHistory.map(h => h.value);
            const color = colors[seriesIdx % colors.length];
            
            // Find annotated points in this series
            const annotatedPoints = sortedHistory
                .map((h, i) => ({ ...h, index: i, date: dates[i], value: values[i], seriesName, originalDate: h.date }))
                .filter(h => h.annotation);
            
            console.log(`ðŸ“ Series "${seriesName}" has ${annotatedPoints.length} annotations`);
            
            annotatedPoints.forEach((point) => {
                // Use saved positions if available, otherwise calculate defaults
                const savedAx = point.annotationAx;
                const savedAy = point.annotationAy;
                const defaultYshift = 40 + (annotationIdx % 4) * 30;
                const defaultAx = annotationIdx % 2 === 0 ? -80 : 80;
                const ax = savedAx !== undefined ? savedAx : defaultAx;
                const ay = savedAy !== undefined ? savedAy : -defaultYshift;
                const align = ax < 0 ? 'right' : 'left';
                
                console.log(`   ðŸ“Œ "${point.annotation}" @ ${point.date}: ax=${ax}, ay=${ay} (saved: ${savedAx !== undefined})`);
                
                layout.annotations.push({
                    x: point.date,
                    y: point.value,
                    text: `<b>${point.annotation}</b>`,
                    showarrow: true,
                    arrowhead: 2,
                    arrowsize: 1,
                    arrowcolor: color,
                    ax: ax,
                    ay: ay,
                    font: { size: 12, color: '#1f2937' },
                    bgcolor: 'rgba(255, 255, 255, 0.95)',
                    bordercolor: color,
                    borderwidth: 2,
                    borderpad: 5,
                    align: align,
                    // Store metadata for saving
                    name: `${seriesName}|${point.originalDate}|${point.annotation}`,
                    captureevents: true
                });
                annotationIdx++;
            });
        });
        console.log(`ðŸ“ Total annotations added: ${annotationIdx}`);
    }
    // For single series (legacy format)
    else if (metric.history && metric.history.length > 0) {
        const sortedHistory = [...metric.history].sort((a, b) => new Date(a.date) - new Date(b.date));
        const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
        const values = sortedHistory.map(h => h.value);
        
        // Add current value annotation for single series
        const lastValue = values[values.length - 1];
        const lastDate = dates[dates.length - 1];
        layout.annotations.push({
            x: lastDate,
            y: lastValue,
            text: `Current: ${lastValue}${metric.unit ? ' ' + metric.unit : ''}`,
            showarrow: true,
            arrowhead: 2,
            arrowsize: 1,
            arrowcolor: '#3b82f6',
            ax: 40,
            ay: -40,
            font: { size: 14, color: '#1e40af', weight: 'bold' },
            bgcolor: 'rgba(255, 255, 255, 0.95)',
            bordercolor: '#3b82f6',
            borderwidth: 2,
            borderpad: 6
        });
        
        const annotatedPoints = sortedHistory
            .map((h, i) => ({ ...h, index: i, date: dates[i], value: values[i], originalDate: sortedHistory[i].date }))
            .filter(h => h.annotation);
        
        annotatedPoints.forEach((point, idx) => {
            // Use saved positions if available
            const savedAx = point.annotationAx;
            const savedAy = point.annotationAy;
            const defaultYshift = 50 + (idx % 3) * 25;
            const defaultAx = idx % 2 === 0 ? -60 : 60;
            const ax = savedAx !== undefined ? savedAx : defaultAx;
            const ay = savedAy !== undefined ? savedAy : -defaultYshift;
            const align = ax < 0 ? 'right' : 'left';
            
            console.log(`   ðŸ“Œ "${point.annotation}" @ ${point.date}: ax=${ax}, ay=${ay} (saved: ${savedAx !== undefined})`);
            
            layout.annotations.push({
                x: point.date,
                y: point.value,
                text: point.annotation,
                showarrow: true,
                arrowhead: 2,
                arrowsize: 1,
                arrowcolor: '#9ca3af',
                ax: ax,
                ay: ay,
                font: { size: 13, color: '#374151' },
                bgcolor: 'rgba(255, 255, 255, 0.98)',
                bordercolor: '#d1d5db',
                borderwidth: 1,
                borderpad: 6,
                align: align,
                // Store metadata for saving
                name: `history|${point.originalDate}|${point.annotation}`,
                captureevents: true
            });
        });
    }
    
    // Check if we're in PowerPoint export mode (screenshot capture)
    const isPowerPointMode = new URLSearchParams(window.location.search).get('ppt_export') === 'true';
    
    const config = {
        responsive: true,
        displayModeBar: !isPowerPointMode,  // Hide controls for PowerPoint export
        staticPlot: isPowerPointMode,  // Disable all interactions for PowerPoint export
        modeBarButtonsToRemove: ['select2d', 'lasso2d', 'autoScale2d'],
        edits: {
            annotationPosition: !isPowerPointMode,  // Only allow dragging in interactive mode
            annotationTail: !isPowerPointMode       // Only allow dragging in interactive mode
        }
    };
    
    Plotly.newPlot('metricTrendChart', data, layout, config).then(() => {
        // Signal that chart is fully rendered for screenshot capture
        document.body.setAttribute('data-plotly-ready', 'true');
        console.log('âœ… Plotly chart fully rendered, set data-plotly-ready');
        
        // Listen for annotation position changes (relayout events)
        const chartDiv = document.getElementById('metricTrendChart');
        chartDiv.on('plotly_relayout', function(eventData) {
            console.log('ðŸ“ Relayout event:', eventData);
            
            // Check if any annotations were moved
            const annotationUpdates = [];
            for (const key in eventData) {
                // Plotly uses format like 'annotations[0].ax' for annotation changes
                const match = key.match(/annotations\[(\d+)\]\.(ax|ay)/);
                if (match) {
                    const annotationIdx = parseInt(match[1]);
                    const prop = match[2];
                    const value = eventData[key];
                    
                    // Find or create update entry for this annotation
                    let update = annotationUpdates.find(u => u.idx === annotationIdx);
                    if (!update) {
                        update = { idx: annotationIdx };
                        annotationUpdates.push(update);
                    }
                    update[prop] = value;
                }
            }
            
            if (annotationUpdates.length > 0) {
                console.log('ðŸ“ Annotation position updates:', annotationUpdates);
                saveAnnotationPositions(layout.annotations, annotationUpdates);
            }
        });
    });
}

// Save annotation positions to server
async function saveAnnotationPositions(annotations, updates) {
    const positions = [];
    
    for (const update of updates) {
        const annotation = annotations[update.idx];
        if (!annotation || !annotation.name) continue;
        
        // Parse the name field: "seriesName|date|text"
        const parts = annotation.name.split('|');
        if (parts.length >= 2) {
            const seriesName = parts[0];
            const date = parts[1];
            
            // Get current positions (use update values or existing)
            const ax = update.ax !== undefined ? update.ax : annotation.ax;
            const ay = update.ay !== undefined ? update.ay : annotation.ay;
            
            positions.push({
                seriesName: seriesName,
                date: date,
                ax: ax,
                ay: ay
            });
        }
    }
    
    if (positions.length === 0) {
        console.log('âš ï¸ No valid positions to save');
        return;
    }
    
    console.log('ðŸ’¾ Saving annotation positions:', positions);
    
    try {
        const response = await fetch(`/api/custom-metrics/${encodeURIComponent(projectName)}/annotation-positions`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                metricName: metricName,
                positions: positions
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('âœ… Annotation positions saved:', result);
            
            // Show brief toast notification
            showToast('Annotation position saved');
        } else {
            const error = await response.text();
            console.error('âŒ Failed to save positions:', error);
        }
    } catch (e) {
        console.error('âŒ Error saving annotation positions:', e);
    }
}

// Simple toast notification
function showToast(message) {
    const existing = document.getElementById('annotation-toast');
    if (existing) existing.remove();
    
    const toast = document.createElement('div');
    toast.id = 'annotation-toast';
    toast.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #22c55e; color: white; padding: 12px 24px; border-radius: 8px; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; transition: opacity 0.3s;';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
    }, 2000);
}
</script>
{% endblock %}
