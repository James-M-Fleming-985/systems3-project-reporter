{% extends "base.html" %}

{% block title %}{{ metric_name }} - Trend Chart{% endblock %}

{% block content %}
<div class="bg-white rounded-lg shadow-lg p-8">
    <div class="mb-6">
        <h2 class="text-3xl font-bold text-gray-800 mb-2">{{ metric_name }}</h2>
        <p class="text-gray-600">{{ project_name }} - Trend Analysis</p>
    </div>
    
    <div id="metricTrendChart" style="width:100%; height:600px;"></div>
    
    <div id="noDataMessage" class="hidden text-center py-12">
        <svg class="mx-auto h-16 w-16 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
        </svg>
        <p class="text-gray-500 text-lg">No historical data available for this metric</p>
    </div>
</div>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
const metricName = "{{ metric_name }}";
const projectName = "{{ project_name }}";

// Load custom metrics from localStorage
const selectedProgram = localStorage.getItem('selectedProgram');
const storageKey = `customMetrics_${selectedProgram}`;
const stored = localStorage.getItem(storageKey);

if (!stored) {
    document.getElementById('noDataMessage').classList.remove('hidden');
    document.getElementById('metricTrendChart').style.display = 'none';
} else {
    try {
        const customMetrics = JSON.parse(stored);
        const metric = customMetrics.find(m => m.name === metricName);
        
        if (!metric || !metric.history || metric.history.length === 0) {
            document.getElementById('noDataMessage').classList.remove('hidden');
            document.getElementById('metricTrendChart').style.display = 'none';
        } else {
            // Render the trend chart
            renderTrendChart(metric);
        }
    } catch (e) {
        console.error('Failed to parse metrics:', e);
        document.getElementById('noDataMessage').classList.remove('hidden');
        document.getElementById('metricTrendChart').style.display = 'none';
    }
}

function renderTrendChart(metric) {
    // Sort history by date
    const sortedHistory = [...metric.history].sort((a, b) => new Date(a.date) - new Date(b.date));
    const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
    const values = sortedHistory.map(h => h.value);
    
    const data = [{
        x: dates,
        y: values,
        type: 'scatter',
        mode: 'lines+markers',
        name: metric.name,
        line: { 
            color: '#3b82f6', 
            width: 4 
        },
        marker: { 
            size: 12,
            color: '#3b82f6',
            line: {
                color: '#1e40af',
                width: 2
            }
        },
        text: sortedHistory.map(h => h.annotation || ''),
        hovertemplate: '<b>%{y}' + (metric.unit ? ' ' + metric.unit : '') + '</b><br>%{x}<br>%{text}<extra></extra>'
    }];
    
    const layout = {
        title: {
            text: `${metric.name} Trend`,
            font: { size: 24, color: '#1f2937', weight: 'bold' }
        },
        yaxis: { 
            title: {
                text: metric.unit ? `Value (${metric.unit})` : 'Value',
                font: { size: 16 }
            },
            zeroline: false,
            gridcolor: '#e5e7eb',
            font: { size: 14 }
        },
        xaxis: { 
            title: {
                text: 'Date',
                font: { size: 16 }
            },
            tickangle: -45,
            automargin: true,
            gridcolor: '#e5e7eb',
            font: { size: 14 }
        },
        margin: { t: 80, b: 120, l: 80, r: 60 },
        paper_bgcolor: '#ffffff',
        plot_bgcolor: '#f9fafb',
        shapes: [],
        annotations: []
    };
    
    // Add target line if defined
    if (metric.target) {
        layout.shapes.push({
            type: 'line',
            x0: dates[0],
            y0: metric.target,
            x1: dates[dates.length - 1],
            y1: metric.target,
            line: {
                color: '#22c55e',
                width: 3,
                dash: 'dash'
            }
        });
        
        // Add target label
        layout.annotations.push({
            x: dates[Math.floor(dates.length / 2)],
            y: metric.target,
            text: `Target: ${metric.target}${metric.unit ? ' ' + metric.unit : ''}`,
            showarrow: false,
            yshift: 20,
            font: { size: 14, color: '#22c55e', weight: 'bold' },
            bgcolor: 'rgba(255, 255, 255, 0.95)',
            bordercolor: '#22c55e',
            borderwidth: 2,
            borderpad: 6
        });
    }
    
    // Add current value annotation
    const lastValue = values[values.length - 1];
    const lastDate = dates[dates.length - 1];
    layout.annotations.push({
        x: lastDate,
        y: lastValue,
        text: `Current: ${lastValue}${metric.unit ? ' ' + metric.unit : ''}`,
        showarrow: true,
        arrowhead: 2,
        arrowsize: 1,
        arrowcolor: '#3b82f6',
        ax: 40,
        ay: -40,
        font: { size: 14, color: '#1e40af', weight: 'bold' },
        bgcolor: 'rgba(255, 255, 255, 0.95)',
        bordercolor: '#3b82f6',
        borderwidth: 2,
        borderpad: 6
    });
    
    // Add annotations for data points with callouts
    const annotatedPoints = sortedHistory
        .map((h, i) => ({ ...h, index: i, date: dates[i], value: values[i] }))
        .filter(h => h.annotation);
    
    annotatedPoints.forEach((point, idx) => {
        const yshift = 50 + (idx % 3) * 25;
        const ax = idx % 2 === 0 ? -60 : 60;
        const align = ax < 0 ? 'right' : 'left';
        
        layout.annotations.push({
            x: point.date,
            y: point.value,
            text: point.annotation,
            showarrow: true,
            arrowhead: 2,
            arrowsize: 1,
            arrowcolor: '#9ca3af',
            ax: ax,
            ay: -yshift,
            font: { size: 13, color: '#374151' },
            bgcolor: 'rgba(255, 255, 255, 0.98)',
            bordercolor: '#d1d5db',
            borderwidth: 1,
            borderpad: 6,
            align: align
        });
    });
    
    const config = {
        responsive: true,
        displayModeBar: false
    };
    
    Plotly.newPlot('metricTrendChart', data, layout, config);
}
</script>
{% endblock %}
