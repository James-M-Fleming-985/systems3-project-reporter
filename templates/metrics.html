{% extends "base.html" %}

{% block title %}Metrics - Systems¬≥ Project Reporter{% endblock %}

{% block content %}
<div class="mb-8">
    <h2 class="text-3xl font-bold text-gray-800 mb-2" id="metricsPageTitle">üìà {{ program_name }} Metrics</h2>
    <p class="text-gray-600" id="metricsPageSubtitle">Key performance indicators and program health metrics</p>
</div>


<!-- Program Selection Check (hidden by default, shown only if no program) -->
<div id="noProgramSelected" class="hidden bg-yellow-50 border-l-4 border-yellow-500 p-6 mb-6">
    <div class="flex items-center">
        <svg class="w-8 h-8 text-yellow-500 mr-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
        </svg>
        <div>
            <h3 class="text-lg font-bold text-yellow-800 mb-2">No Program Selected</h3>
            <p class="text-yellow-700 mb-3">Please select a program from the Portfolio Dashboard to view its metrics.</p>
            <a href="/dashboard" class="inline-block px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 transition">
                Go to Portfolio Dashboard
            </a>
        </div>
    </div>
</div>

<!-- Metrics Content (visible by default, assuming program selected) -->
<div id="metricsContent">
    
    <!-- Current Program Banner -->
    <div class="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
        <div class="flex items-center justify-between">
            <div class="flex items-center">
                <svg class="w-6 h-6 text-blue-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <div>
                    <p class="font-semibold text-blue-800">Viewing Metrics For: <span id="selectedProgramNameMetrics"></span></p>
                    <p class="text-sm text-blue-700">Last Updated: <span id="lastUpdated"></span></p>
                </div>
            </div>
            <a href="/dashboard" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition text-sm">
                Change Program
            </a>
        </div>
    </div>

    <!-- KPI Summary Cards -->
    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
        <!-- Schedule Performance Index (SPI) -->
        <div class="bg-white rounded-lg shadow p-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-semibold text-gray-600">Schedule Performance</h3>
                <div class="bg-green-100 rounded-full p-2">
                    <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                </div>
            </div>
            <p class="text-3xl font-bold text-gray-900" id="spiValue">-</p>
            <p class="text-xs text-gray-500 mt-1">SPI (Target: ‚â•1.0)</p>
        </div>

        <!-- Completion Rate -->
        <div class="bg-white rounded-lg shadow p-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-semibold text-gray-600">Completion Rate</h3>
                <div class="bg-blue-100 rounded-full p-2">
                    <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path>
                    </svg>
                </div>
            </div>
            <p class="text-3xl font-bold text-gray-900" id="completionRate">-</p>
            <p class="text-xs text-gray-500 mt-1">Milestones Completed</p>
        </div>

        <!-- Risk Score -->
        <div class="bg-white rounded-lg shadow p-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-semibold text-gray-600">Risk Score</h3>
                <div class="bg-red-100 rounded-full p-2">
                    <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                    </svg>
                </div>
            </div>
            <p class="text-3xl font-bold text-gray-900" id="riskScore">-</p>
            <p class="text-xs text-gray-500 mt-1">Open Risks</p>
        </div>

        <!-- Change Velocity -->
        <div class="bg-white rounded-lg shadow p-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-sm font-semibold text-gray-600">Change Velocity</h3>
                <div class="bg-yellow-100 rounded-full p-2">
                    <svg class="w-5 h-5 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                    </svg>
                </div>
            </div>
            <p class="text-3xl font-bold text-gray-900" id="changeVelocity">-</p>
            <p class="text-xs text-gray-500 mt-1">Changes This Month</p>
        </div>
    </div>

    <!-- Detailed Metrics -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
        
        <!-- Milestone Health Chart -->
        <div class="bg-white rounded-lg shadow p-6">
            <h3 class="text-lg font-bold text-gray-800 mb-4">Milestone Health</h3>
            <div id="milestoneHealthChart" style="width:100%; height:300px;"></div>
        </div>

        <!-- Risk Distribution -->
        <div class="bg-white rounded-lg shadow p-6">
            <h3 class="text-lg font-bold text-gray-800 mb-4">Risk Distribution</h3>
            <div id="riskDistributionChart" style="width:100%; height:300px;"></div>
        </div>
    </div>

    <!-- Timeline Metrics -->
    <div class="bg-white rounded-lg shadow p-6 mb-8">
        <h3 class="text-lg font-bold text-gray-800 mb-4">Schedule Trend</h3>
        <div id="scheduleTrendChart" style="width:100%; height:400px;"></div>
    </div>

    <!-- Custom Metrics Table -->
    <div class="bg-white rounded-lg shadow p-6">
        <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-bold text-gray-800">Custom Program Metrics</h3>
            <div class="flex space-x-2">
                <button id="exportMetricsBtn" class="px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition text-sm">
                    üì• Export
                </button>
                <button id="importMetricsBtn" class="px-3 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition text-sm">
                    üì§ Import
                </button>
                <button id="addMetricBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition text-sm">
                    + Add Metric
                </button>
            </div>
        </div>
        <p class="text-gray-500 text-sm mb-4">Define and track custom metrics specific to this program. Update values regularly to see trends. <strong>Pro tip:</strong> Export your metrics regularly to backup your data!</p>
        
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200">
                <thead>
                    <tr>
                        <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Metric Name
                        </th>
                        <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Current Value
                        </th>
                        <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Target
                        </th>
                        <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Target Date
                        </th>
                        <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Status
                        </th>
                        <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Last Updated
                        </th>
                        <th class="px-6 py-3 bg-gray-50 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            Actions
                        </th>
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200" id="customMetricsTable">
                    <tr id="noMetricsRow">
                        <td colspan="7" class="px-6 py-4 text-center text-sm text-gray-500">
                            No custom metrics defined yet. Click "Add Metric" to create one.
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

</div>

<!-- Add/Edit Custom Metric Modal -->
<div id="addMetricModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 id="modalTitle" class="text-lg font-bold text-gray-900 mb-4">Add Custom Metric</h3>
            <form id="addMetricForm">
                <input type="hidden" id="editingMetricIndex" value="">
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Metric Name</label>
                    <input type="text" id="metricName" required 
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="e.g., Team Velocity">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Current Value</label>
                    <input type="number" step="0.01" id="metricValue" required 
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="e.g., 85">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Target Value</label>
                    <input type="number" step="0.01" id="metricTarget" required 
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="e.g., 100">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Target Date</label>
                    <input type="date" id="metricTargetDate" required
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Unit (optional)</label>
                    <input type="text" id="metricUnit" 
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="e.g., points, hours, %">
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button type="button" id="cancelMetricBtn"
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition">
                        Cancel
                    </button>
                    <button type="submit" id="submitMetricBtn"
                            class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition">
                        Add Metric
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Update Value Modal -->
<div id="updateValueModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 class="text-lg font-bold text-gray-900 mb-4">Update Metric Value</h3>
            <p class="text-sm text-gray-600 mb-4">Update the current value to track progress over time</p>
            <form id="updateValueForm">
                <input type="hidden" id="updateMetricIndex" value="">
                
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Metric Name</label>
                    <input type="text" id="updateMetricNameDisplay" disabled
                           class="w-full px-3 py-2 border border-gray-300 rounded bg-gray-100 text-gray-700">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">New Value</label>
                    <input type="number" step="0.01" id="updateMetricValue" required 
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="Enter new value">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Date</label>
                    <input type="date" id="updateMetricDate" required 
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <p class="text-xs text-gray-500 mt-1">Set the date for this metric value (useful for backdating or future entries)</p>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Annotation / Callout (Optional)</label>
                    <textarea id="updateMetricAnnotation" rows="2"
                           class="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="Add a note that will appear on the trend chart (e.g., 'New equipment installed', 'Team training completed')"></textarea>
                    <p class="text-xs text-gray-500 mt-1">This will appear as an annotation on the trend chart at this data point</p>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button type="button" id="cancelUpdateBtn"
                            class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition">
                        Cancel
                    </button>
                    <button type="submit"
                            class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition">
                        Update Value
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Metric Trend Chart Modal -->
<div id="trendChartModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
    <div class="relative top-10 mx-auto p-5 border w-3/4 max-w-4xl shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <div class="flex items-center justify-between mb-4">
                <h3 id="trendChartTitle" class="text-lg font-bold text-gray-900">Metric Trend</h3>
                <button id="closeTrendChartBtn" class="text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <div id="metricTrendChart" style="width:100%; height:400px;"></div>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="deleteConfirmModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
    <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
        <div class="mt-3 text-center">
            <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
                <svg class="h-6 w-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
            </div>
            <h3 class="text-lg font-bold text-gray-900 mb-2">Delete Custom Metric</h3>
            <p class="text-sm text-gray-500 mb-6">Are you sure you want to delete "<span id="deleteMetricName" class="font-semibold"></span>"? This action cannot be undone and will remove all historical data for this metric.</p>
            <div class="flex justify-center gap-3">
                <button id="cancelDeleteBtn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400">
                    Cancel
                </button>
                <button id="confirmDeleteBtn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">
                    Delete Metric
                </button>
            </div>
        </div>
    </div>
</div>



{% endblock %}

{% block scripts %}
<script>
console.log('=== METRICS SCRIPT BLOCK STARTING ===');
</script>
<script id="metrics-data-script">
// Embed metrics data safely - this should be valid JSON
try {
    console.log('About to parse metrics data...');
    var METRICS_DATA = {{ metrics | tojson | safe }};
    console.log('‚úÖ METRICS_DATA loaded successfully:', METRICS_DATA);
} catch (e) {
    console.error('‚ùå Error loading METRICS_DATA:', e);
    console.error('Error details:', e.message, e.stack);
    var METRICS_DATA = null;
}
</script>
<script>
// Backend provides pre-filtered data for selected project
const projectName = "{{ project.project_name }}";
const projectCode = "{{ project.project_code }}";
const metricsData = {{ metrics | tojson | safe }};

console.log('üìä METRICS - Rendering metrics for', projectName);

// All initialization in one DOMContentLoaded event
document.addEventListener('DOMContentLoaded', function() {
    // Set selectedProgram in localStorage for custom metrics
    // This ensures custom metrics are loaded for the correct project
    localStorage.setItem('selectedProgram', projectName);
    console.log('üîß Set selectedProgram to:', projectName);
    
    // Update UI with project name
    const programNameSpan = document.getElementById('selectedProgramNameMetrics');
    if (programNameSpan) {
        programNameSpan.textContent = projectName;
    }
    
    // Load metrics data (already provided by backend)
    loadMetricsData(projectName);
    
    // Initialize modal controls
    initializeModalControls();
    
    // Load custom metrics
    loadCustomMetrics();
});

function loadMetricsData(programName) {
    try {
        // Use metrics data from global variable (set by server)
        const metrics = METRICS_DATA;
        
        if (!metrics) {
            console.error('No metrics data available');
            return;
        }
        
        console.log('Loading metrics data:', metrics);
        
        // Update KPI cards with real data
        console.log('Updating KPI cards...');
        const spiEl = document.getElementById('spiValue');
        const completionEl = document.getElementById('completionRate');
        const riskEl = document.getElementById('riskScore');
        const changeEl = document.getElementById('changeVelocity');
        
        console.log('Found elements:', {spiEl, completionEl, riskEl, changeEl});
        
        if (spiEl) spiEl.textContent = metrics.spi || '1.00';
        if (completionEl) completionEl.textContent = (metrics.completion_rate || 0) + '%';
        if (riskEl) riskEl.textContent = metrics.risk_score !== undefined ? metrics.risk_score : '-';
        if (changeEl) changeEl.textContent = '-'; // TODO: calculate from changes
        
        // Update last updated timestamp
        const lastUpdatedSpan = document.getElementById('lastUpdated');
        if (lastUpdatedSpan && metrics.last_updated) {
            const date = new Date(metrics.last_updated);
            lastUpdatedSpan.textContent = date.toLocaleString();
        }
        
        // Create charts with real data
        console.log('Creating milestone health chart...');
        createMilestoneHealthChart(metrics.milestone_health || {completed: 0, in_progress: 0, not_started: 0, late: 0});
        
        console.log('Creating risk distribution chart...');
        createRiskDistributionChart(metrics.risk_distribution || {critical: 0, high: 0, medium: 0, low: 0});
        
        console.log('Creating schedule trend chart...');
        createScheduleTrendChart(metrics.schedule_trend || {periods: [], spi_values: []});
        
        console.log('‚úÖ All charts created successfully');
    } catch (error) {
        console.error('‚ùå Error loading metrics data:', error);
        console.error('Error stack:', error.stack);
    }
}

function createMilestoneHealthChart(healthData) {
    console.log('createMilestoneHealthChart called with:', healthData);
    const chartDiv = document.getElementById('milestoneHealthChart');
    console.log('milestoneHealthChart div found:', chartDiv);
    
    if (!chartDiv) {
        console.error('‚ùå milestoneHealthChart div not found!');
        return;
    }
    
    // Use real milestone health data
    const data = [{
        values: [
            healthData.completed || 0,
            healthData.in_progress || 0,
            healthData.not_started || 0,
            healthData.late || 0
        ],
        labels: ['Completed', 'In Progress', 'Not Started', 'Late/Overdue'],
        type: 'pie',
        marker: {
            colors: ['#22c55e', '#eab308', '#9ca3af', '#ef4444']
        }
    }];
    
    const layout = {
        showlegend: true,
        margin: { t: 0, b: 0, l: 0, r: 0 }
    };
    
    console.log('Plotting milestone health chart...');
    Plotly.newPlot('milestoneHealthChart', data, layout, {responsive: true});
    console.log('‚úÖ Milestone health chart plotted');
}

function createRiskDistributionChart(riskDistribution) {
    console.log('createRiskDistributionChart called with:', riskDistribution);
    const chartDiv = document.getElementById('riskDistributionChart');
    console.log('riskDistributionChart div found:', chartDiv);
    
    if (!chartDiv) {
        console.error('‚ùå riskDistributionChart div not found!');
        return;
    }
    
    // Use real risk distribution data
    const data = [{
        x: ['Critical', 'High', 'Medium', 'Low'],
        y: [
            riskDistribution.critical || 0,
            riskDistribution.high || 0,
            riskDistribution.medium || 0,
            riskDistribution.low || 0
        ],
        type: 'bar',
        marker: {
            color: ['#7f1d1d', '#ef4444', '#f59e0b', '#10b981']
        }
    }];
    
    const layout = {
        yaxis: { title: 'Count' },
        margin: { t: 10, b: 40, l: 40, r: 10 }
    };
    
    console.log('Plotting risk distribution chart...');
    Plotly.newPlot('riskDistributionChart', data, layout, {responsive: true});
    console.log('‚úÖ Risk distribution chart plotted');
}

function createScheduleTrendChart(trendData) {
    console.log('createScheduleTrendChart called with:', trendData);
    const chartDiv = document.getElementById('scheduleTrendChart');
    console.log('scheduleTrendChart div found:', chartDiv);
    
    if (!chartDiv) {
        console.error('‚ùå scheduleTrendChart div not found!');
        return;
    }
    
    if (!trendData || !trendData.periods || trendData.periods.length === 0) {
        console.log('No trend data available, showing empty state');
        // Show empty state
        document.getElementById('scheduleTrendChart').innerHTML = 
            '<div class="flex items-center justify-center h-full text-gray-500">No trend data available yet</div>';
        return;
    }
    
    // Use real schedule trend data
    const data = [{
        x: trendData.periods,
        y: trendData.spi_values,
        type: 'scatter',
        mode: 'lines+markers',
        name: 'SPI Trend',
        line: { color: '#3b82f6', width: 3 },
        marker: { size: 8 }
    }];
    
    const layout = {
        yaxis: { 
            title: 'Schedule Performance Index',
            zeroline: false
        },
        xaxis: { 
            title: 'Time Period',
            tickangle: -45
        },
        margin: { t: 10, b: 60, l: 50, r: 10 },
        shapes: [{
            type: 'line',
            x0: trendData.periods[0],
            y0: 1.0,
            x1: trendData.periods[trendData.periods.length - 1],
            y1: 1.0,
            line: {
                color: '#22c55e',
                width: 2,
                dash: 'dash'
            }
        }],
        annotations: [{
            x: trendData.periods[Math.floor(trendData.periods.length / 2)],
            y: 1.0,
            text: 'Target (1.0)',
            showarrow: false,
            yshift: 10,
            font: { size: 10, color: '#22c55e' }
        }]
    };
    
    console.log('Plotting schedule trend chart...');
    Plotly.newPlot('scheduleTrendChart', data, layout, {responsive: true});
    console.log('‚úÖ Schedule trend chart plotted');
}

// Custom Metrics Management - Server-side persistence
let customMetrics = [];

// Load custom metrics from server (with localStorage fallback for migration)
async function loadCustomMetrics() {
    console.log('loadCustomMetrics called');
    const selectedProgram = localStorage.getItem('selectedProgram');
    console.log('Selected program for custom metrics:', selectedProgram);
    
    if (!selectedProgram) {
        console.log('No program selected, skipping custom metrics load');
        return;
    }
    
    try {
        // Try to load from server first
        console.log('üì° Loading metrics from server...');
        const response = await fetch(`/api/custom-metrics/${encodeURIComponent(selectedProgram)}`);
        
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.metrics && data.metrics.length > 0) {
                customMetrics = data.metrics;
                console.log(`‚úÖ Loaded ${customMetrics.length} metrics from server`);
                renderCustomMetrics();
                return;
            } else {
                console.log('Server returned no metrics, checking localStorage for migration...');
            }
        } else {
            console.warn('Server metrics API not available, falling back to localStorage');
        }
    } catch (error) {
        console.warn('Error loading from server, falling back to localStorage:', error);
    }
    
    // Fallback: Try localStorage and migrate to server if found
    console.log('üîç Checking localStorage for metrics to migrate...');
    await loadAndMigrateFromLocalStorage(selectedProgram);
}

// Migrate localStorage metrics to server
async function loadAndMigrateFromLocalStorage(selectedProgram) {
    
// Migrate localStorage metrics to server
async function loadAndMigrateFromLocalStorage(selectedProgram) {
    // Debug: List ALL localStorage keys first
    console.log('üîç ALL localStorage keys:');
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        console.log(`  - ${key}`);
    }
    
    // Debug: List all localStorage keys that might contain custom metrics
    console.log('üîç Checking all localStorage keys for custom metrics:');
    const allMetricKeys = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.includes('customMetrics')) {
            console.log(`  - Found: ${key}`);
            allMetricKeys.push(key);
            const data = localStorage.getItem(key);
            if (data) {
                try {
                    const parsed = JSON.parse(data);
                    console.log(`    ‚îî‚îÄ Contains ${parsed.length} metrics`);
                } catch (e) {
                    console.log(`    ‚îî‚îÄ Invalid JSON`);
                }
            }
        }
    }
    
    if (allMetricKeys.length === 0) {
        console.error('‚ùå NO customMetrics keys found in localStorage at all!');
        console.error('üíî No data to migrate.');
        return;
    }
    
    // Try to find metrics with multiple key variations
    const storageKey = `customMetrics_${selectedProgram}`;
    let stored = localStorage.getItem(storageKey);
    console.log(`Looking for key: ${storageKey}`);
    
    // If not found, try variations without file extensions
    if (!stored) {
        const cleanProgramName = selectedProgram
            .replace(/\.xml$/i, '')
            .replace(/\.xlsx$/i, '')
            .replace(/\.yaml$/i, '')
            .replace(/-\d+$/, '')  // Remove trailing numbers like -12
            .trim();
        
        console.log(`üîç Trying clean name: ${cleanProgramName}`);
        const cleanKey = `customMetrics_${cleanProgramName}`;
        stored = localStorage.getItem(cleanKey);
        
        if (stored) {
            console.log(`‚úÖ Found metrics under clean name: ${cleanKey}`);
        }
    }
    
    // If still not found, check if there's only one customMetrics key and use it
    if (!stored && allMetricKeys.length === 1) {
        console.log(`üí° Found exactly one customMetrics key, attempting to use it`);
        stored = localStorage.getItem(allMetricKeys[0]);
        if (stored) {
            console.log(`‚úÖ Using metrics from: ${allMetricKeys[0]}`);
        }
    }
    
    if (stored) {
        try {
            customMetrics = JSON.parse(stored);
            console.log('‚úÖ Parsed custom metrics from localStorage:', customMetrics);
            
            // Migrate old metrics to include history if needed
            customMetrics = customMetrics.map(metric => {
                if (!metric.history) {
                    metric.history = [{
                        value: metric.value,
                        date: metric.lastUpdated
                    }];
                }
                if (!metric.targetDate) {
                    metric.targetDate = null;
                }
                return metric;
            });
            
            // Migrate to server
            console.log('üì§ Migrating metrics to server...');
            await saveCustomMetrics();
            console.log('‚úÖ Migration complete! Metrics now stored on server.');
            
            renderCustomMetrics();
        } catch (error) {
            console.error('Error parsing/migrating localStorage metrics:', error);
        }
    } else {
        console.log('‚ùå No stored custom metrics found');
    }
}
    console.log('üîç ALL localStorage keys:');
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        console.log(`  - ${key}`);
    }
    
    // Debug: List all localStorage keys that might contain custom metrics
    console.log('üîç Checking all localStorage keys for custom metrics:');
    const allMetricKeys = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.includes('customMetrics')) {
            console.log(`  - Found: ${key}`);
            allMetricKeys.push(key);
            const data = localStorage.getItem(key);
            if (data) {
                try {
                    const parsed = JSON.parse(data);
                    console.log(`    ‚îî‚îÄ Contains ${parsed.length} metrics`);
                } catch (e) {
                    console.log(`    ‚îî‚îÄ Invalid JSON`);
                }
            }
        }
    }
    
    if (allMetricKeys.length === 0) {
        console.error('‚ùå NO customMetrics keys found in localStorage at all!');
        console.error('üíî Your custom metrics data has been lost.');
        console.error('üí° This can happen if:');
        console.error('   1. Browser localStorage was cleared');
        console.error('   2. Using incognito/private mode');
        console.error('   3. Different browser than before');
        console.error('   4. Browser updated and cleared data');
    }
    
    // Try to find metrics with multiple key variations
    const storageKey = `customMetrics_${selectedProgram}`;
    let stored = localStorage.getItem(storageKey);
    console.log(`Looking for key: ${storageKey}`);
    
    // If not found, try variations without file extensions
    if (!stored) {
        const cleanProgramName = selectedProgram
            .replace(/\.xml$/i, '')
            .replace(/\.xlsx$/i, '')
            .replace(/\.yaml$/i, '')
            .replace(/-\d+$/, '')  // Remove trailing numbers like -12
            .trim();
        
        console.log(`üîç Trying clean name: ${cleanProgramName}`);
        const cleanKey = `customMetrics_${cleanProgramName}`;
        stored = localStorage.getItem(cleanKey);
        
        if (stored) {
            console.log(`‚úÖ Found metrics under clean name: ${cleanKey}`);
            // Migrate to new key
            localStorage.setItem(storageKey, stored);
            console.log(`‚úÖ Migrated metrics to: ${storageKey}`);
        }
    }
    
    // If still not found, check if there's only one customMetrics key and use it
    if (!stored && allMetricKeys.length === 1) {
        console.log(`üí° Found exactly one customMetrics key, attempting to use it`);
        stored = localStorage.getItem(allMetricKeys[0]);
        if (stored) {
            console.log(`‚úÖ Using metrics from: ${allMetricKeys[0]}`);
            // Migrate to new key
            localStorage.setItem(storageKey, stored);
            console.log(`‚úÖ Migrated metrics to: ${storageKey}`);
        }
    }
    
    console.log('Custom metrics from storage:', stored);
    
    if (stored) {
        customMetrics = JSON.parse(stored);
        console.log('‚úÖ Parsed custom metrics:', customMetrics);
        
        // Migrate old metrics to include history if needed
        customMetrics = customMetrics.map(metric => {
            if (!metric.history) {
                metric.history = [{
                    value: metric.value,
                    date: metric.lastUpdated
                }];
            }
            if (!metric.targetDate) {
                metric.targetDate = null;
            }
            return metric;
        });
        
        console.log('Calling renderCustomMetrics...');
        renderCustomMetrics();
    } else {
        console.log('‚ùå No stored custom metrics found for this program');
        console.log('üí° You may need to re-create your custom metrics');
    }
}

// Save custom metrics to localStorage
// Save custom metrics to server (with localStorage backup)
async function saveCustomMetrics() {
    const selectedProgram = localStorage.getItem('selectedProgram');
    if (!selectedProgram) return;
    
    try {
        // Save to server
        console.log('üíæ Saving metrics to server...');
        const response = await fetch(`/api/custom-metrics/${encodeURIComponent(selectedProgram)}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ metrics: customMetrics })
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log(`‚úÖ Saved ${result.count} metrics to server`);
            
            // Also save to localStorage as backup
            const storageKey = `customMetrics_${selectedProgram}`;
            localStorage.setItem(storageKey, JSON.stringify(customMetrics));
            console.log('‚úÖ Backup saved to localStorage');
        } else {
            console.error('Failed to save to server, saving to localStorage only');
            const storageKey = `customMetrics_${selectedProgram}`;
            localStorage.setItem(storageKey, JSON.stringify(customMetrics));
        }
    } catch (error) {
        console.error('Error saving to server:', error);
        // Fallback to localStorage
        const storageKey = `customMetrics_${selectedProgram}`;
        localStorage.setItem(storageKey, JSON.stringify(customMetrics));
        console.log('‚ö†Ô∏è  Saved to localStorage only (server unavailable)');
    }
}

// Calculate status and color
function getMetricStatus(value, target) {
    const percentage = target > 0 ? (value / target) * 100 : 0;
    let status, color;
    
    if (percentage >= 100) {
        status = 'On Track';
        color = 'text-green-600';
    } else if (percentage >= 70) {
        status = 'At Risk';
        color = 'text-yellow-600';
    } else {
        status = 'Behind';
        color = 'text-red-600';
    }
    
    return { status, color, percentage: percentage.toFixed(1) };
}

// Render custom metrics table
function renderCustomMetrics() {
    console.log('renderCustomMetrics called, customMetrics:', customMetrics);
    const tbody = document.getElementById('customMetricsTable');
    const noMetricsRow = document.getElementById('noMetricsRow');
    
    console.log('Found table elements:', {tbody, noMetricsRow});
    
    if (!tbody) {
        console.error('‚ùå customMetricsTable not found!');
        return;
    }
    
    // Clear existing rows (except no metrics row) FIRST
    const existingRows = tbody.querySelectorAll('tr:not(#noMetricsRow)');
    existingRows.forEach(row => row.remove());
    
    if (customMetrics.length === 0) {
        console.log('No custom metrics to display');
        if (noMetricsRow) {
            noMetricsRow.style.display = 'table-row';
        }
        return;
    }
    
        
    // Hide "no metrics" message
    if (noMetricsRow) {
        noMetricsRow.style.display = 'none';
    }
    
    // Add metric rows
    customMetrics.forEach((metric, index) => {
        const { status, color, percentage } = getMetricStatus(metric.value, metric.target);
        const targetDateStr = metric.targetDate ? new Date(metric.targetDate).toLocaleDateString() : 'Not set';
        
        const row = document.createElement('tr');
        row.className = 'hover:bg-gray-50';
        row.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                ${metric.name}
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                ${metric.value}${metric.unit ? ' ' + metric.unit : ''}
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                ${metric.target}${metric.unit ? ' ' + metric.unit : ''}
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-600">
                ${targetDateStr}
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm ${color} font-semibold">
                ${status} (${percentage}%)
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                ${new Date(metric.lastUpdated).toLocaleDateString()}
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm space-x-2">
                <button onclick="updateMetricValue(${index})" class="text-blue-600 hover:text-blue-800">Update</button>
                <button onclick="editMetric(${index})" class="text-indigo-600 hover:text-indigo-800">Edit</button>
                <button onclick="showTrendChart(${index})" class="text-green-600 hover:text-green-800">Trend</button>
                <button onclick="deleteMetric(${index})" class="text-red-600 hover:text-red-800">Delete</button>
            </td>
        `;
        tbody.appendChild(row);
    });
}

// Edit a custom metric
function editMetric(index) {
    const metric = customMetrics[index];
    
    document.getElementById('modalTitle').textContent = 'Edit Custom Metric';
    document.getElementById('submitMetricBtn').textContent = 'Save Changes';
    document.getElementById('editingMetricIndex').value = index;
    
    document.getElementById('metricName').value = metric.name;
    document.getElementById('metricValue').value = metric.value;
    document.getElementById('metricTarget').value = metric.target;
    document.getElementById('metricTargetDate').value = metric.targetDate || '';
    document.getElementById('metricUnit').value = metric.unit || '';
    
    document.getElementById('addMetricModal').classList.remove('hidden');
}

// Update metric value (keeps history)
function updateMetricValue(index) {
    const metric = customMetrics[index];
    
    document.getElementById('updateMetricNameDisplay').value = metric.name;
    document.getElementById('updateMetricValue').value = metric.value;
    document.getElementById('updateMetricIndex').value = index;
    
    // Set today's date as default
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('updateMetricDate').value = today;
    
    document.getElementById('updateValueModal').classList.remove('hidden');
}

// Show trend chart for a metric
function showTrendChart(index) {
    const metric = customMetrics[index];
    
    console.log('üìä showTrendChart called for metric:', metric.name);
    console.log('üìä Metric history:', metric.history);
    console.log('üìä Metric series:', metric.series);
    
    // Check if we have multi-series data
    const hasSeries = metric.series && Object.keys(metric.series).length > 0;
    
    if (!hasSeries && (!metric.history || metric.history.length === 0)) {
        alert('No history available for this metric yet.');
        return;
    }
    
    console.log(`üìä Rendering chart with ${hasSeries ? 'multi-series' : 'single-series'} mode`);
    console.log(`üìä History array length: ${metric.history ? metric.history.length : 0}`);
    
    const selectedProgram = localStorage.getItem('selectedProgram');
    const annotationPositionsKey = `annotationPositions_${selectedProgram}_${metric.name}`;
    
    document.getElementById('trendChartTitle').textContent = `${metric.name} - Trend Chart`;
    
    const colors = ['#3b82f6', '#ef4444', '#22c55e', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4', '#f97316'];
    const data = [];
    
    let allDates = [];
    let targetValue = metric.target;
    
    if (hasSeries) {
        // Multi-series mode: plot each series as a separate line
        console.log('Rendering multi-series chart with series:', Object.keys(metric.series));
        
        Object.keys(metric.series).forEach((seriesName, idx) => {
            const seriesData = metric.series[seriesName];
            if (!seriesData || seriesData.length === 0) return;
            
            const sortedData = [...seriesData].sort((a, b) => new Date(a.date) - new Date(b.date));
            const dates = sortedData.map(h => new Date(h.date).toLocaleDateString());
            const values = sortedData.map(h => h.value);
            
            // Collect all unique dates for target line
            dates.forEach(d => {
                if (!allDates.includes(d)) allDates.push(d);
            });
            
            data.push({
                x: dates,
                y: values,
                type: 'scatter',
                mode: 'lines+markers',
                name: seriesName,
                line: { color: colors[idx % colors.length], width: 3 },
                marker: { size: 8 },
                text: sortedData.map(h => h.annotation || ''),
                hovertemplate: '%{y}' + (metric.unit ? ' ' + metric.unit : '') + '<br>%{x}<br>%{text}<extra></extra>'
            });
        });
        
        // Sort allDates chronologically
        allDates.sort((a, b) => new Date(a) - new Date(b));
        
    } else {
        // Single-series mode: use legacy history array
        console.log('Rendering single-series chart from history array');
        const sortedHistory = [...metric.history].sort((a, b) => new Date(a.date) - new Date(b.date));
        const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
        const values = sortedHistory.map(h => h.value);
        allDates = dates;
        
        data.push({
            x: dates,
            y: values,
            type: 'scatter',
            mode: 'lines+markers',
            name: metric.name,
            line: { color: '#3b82f6', width: 3 },
            marker: { size: 8 },
            text: sortedHistory.map(h => h.annotation || ''),
            hovertemplate: '%{y}' + (metric.unit ? ' ' + metric.unit : '') + '<br>%{x}<br>%{text}<extra></extra>'
        });
    }
    
    const layout = {
        yaxis: { 
            title: metric.unit ? `Value (${metric.unit})` : 'Value',
            zeroline: false
        },
        xaxis: { 
            title: 'Date',
            tickangle: -45
        },
        margin: { t: 40, b: 60, l: 60, r: 10 },
        shapes: targetValue ? [{
            type: 'line',
            x0: allDates[0],
            y0: targetValue,
            x1: allDates[allDates.length - 1],
            y1: targetValue,
            line: {
                color: '#22c55e',
                width: 2,
                dash: 'dash'
            }
        }] : [],
        annotations: []
    };
    
    // Add target line annotation - position it higher to avoid data overlap
    if (targetValue) {
        layout.annotations.push({
            x: allDates[Math.floor(allDates.length / 2)],
            y: targetValue,
            text: `Target (${targetValue}${metric.unit ? ' ' + metric.unit : ''})`,
            showarrow: false,
            yshift: 20,
            font: { size: 10, color: '#22c55e', weight: 'bold' },
            bgcolor: 'rgba(255, 255, 255, 0.8)',
            borderpad: 2
        });
    }
    
    // Fix x-axis to rotate date labels and add margin
    layout.xaxis = {
        title: 'Date',
        tickangle: -45,
        automargin: true
    };
    layout.margin = { b: 100, t: 60, l: 60, r: 30 };
    
    // Add user annotations for data points with callouts
    // Smart positioning to prevent overlap
    let annotatedPoints = [];
    
    if (!hasSeries && metric.history) {
        // Single-series mode: get annotations from history
        const sortedHistory = [...metric.history].sort((a, b) => new Date(a.date) - new Date(b.date));
        const dates = sortedHistory.map(h => new Date(h.date).toLocaleDateString());
        const values = sortedHistory.map(h => h.value);
        annotatedPoints = sortedHistory
            .map((h, i) => ({ ...h, index: i, date: dates[i], value: values[i] }))
            .filter(h => h.annotation);
    } else if (hasSeries) {
        // Multi-series mode: collect annotations from all series
        Object.keys(metric.series).forEach(seriesName => {
            const seriesData = metric.series[seriesName];
            if (!seriesData) return;
            
            const sortedData = [...seriesData].sort((a, b) => new Date(a.date) - new Date(b.date));
            const dates = sortedData.map(h => new Date(h.date).toLocaleDateString());
            const values = sortedData.map(h => h.value);
            
            sortedData
                .map((h, i) => ({ ...h, index: i, date: dates[i], value: values[i], series: seriesName }))
                .filter(h => h.annotation)
                .forEach(point => annotatedPoints.push(point));
        });
    }
    
    // Load saved annotation positions from localStorage
    let savedPositions = {};
    try {
        const saved = localStorage.getItem(annotationPositionsKey);
        if (saved) {
            savedPositions = JSON.parse(saved);
            console.log('Loaded saved annotation positions:', savedPositions);
        }
    } catch (e) {
        console.warn('Failed to load annotation positions:', e);
    }
    
    annotatedPoints.forEach((point, idx) => {
        // Check if we have saved position for this annotation
        const savedPos = savedPositions[point.date];
        
        let ax, ay;
        if (savedPos) {
            // Use saved position
            ax = savedPos.ax;
            ay = savedPos.ay;
            console.log('Using saved position for', point.date, ':', { ax, ay });
        } else {
            // Calculate default positions to avoid overlap - use alternating sides and heights
            const yshiftBase = 40;
            const yshift = yshiftBase + (idx % 3) * 25; // Stagger heights
            ax = idx % 2 === 0 ? -60 : 60; // Alternate left/right
            ay = -yshift;
        }
        
        const align = ax < 0 ? 'right' : 'left';
        
        layout.annotations.push({
            x: point.date,
            y: point.value,
            text: point.annotation,
            showarrow: true,
            arrowhead: 2,
            arrowsize: 1,
            arrowwidth: 1.5,
            arrowcolor: '#6366f1',
            ax: ax,
            ay: ay,
            bgcolor: 'rgba(255, 255, 255, 0.95)',
            bordercolor: '#6366f1',
            borderwidth: 1.5,
            borderpad: 5,
            font: { size: 10, color: '#1f2937' },
            align: align,
            xanchor: align,
            captureevents: true  // Allow annotations to be interactive
        });
    });
    
    // Configure Plotly with editable annotations
    const config = {
        responsive: true,
        editable: true,  // Enable editing mode
        displayModeBar: true,
        modeBarButtonsToAdd: ['drawopenpath', 'eraseshape'],
        displaylogo: false
    };
    
    Plotly.newPlot('metricTrendChart', data, layout, config);
    
    // Listen for annotation changes and save positions
    const chartDiv = document.getElementById('metricTrendChart');
    chartDiv.on('plotly_relayout', function(eventData) {
        // Check if annotations were updated
        if (eventData && Object.keys(eventData).some(key => key.startsWith('annotations'))) {
            console.log('Annotation positions changed:', eventData);
            
            // Get current layout
            const currentLayout = chartDiv.layout;
            if (currentLayout.annotations) {
                // Save annotation positions
                const positions = {};
                currentLayout.annotations.forEach(ann => {
                    // Save positions keyed by the x value (date) to match them up
                    if (ann.x && ann.ax !== undefined && ann.ay !== undefined) {
                        positions[ann.x] = {
                            ax: ann.ax,
                            ay: ann.ay
                        };
                    }
                });
                
                localStorage.setItem(annotationPositionsKey, JSON.stringify(positions));
                console.log('Saved annotation positions to localStorage:', positions);
            }
        }
    });
    
    // Add instructions for users
    const instructionDiv = document.createElement('div');
    instructionDiv.className = 'text-xs text-gray-500 text-center mt-2 p-2 bg-blue-50 border border-blue-200 rounded';
    instructionDiv.innerHTML = 'üí° <strong>Tip:</strong> Click and drag the callout boxes to reposition them';
    
    // Insert instructions before the chart if not already present
    if (!chartDiv.previousElementSibling?.classList?.contains('bg-blue-50')) {
        chartDiv.parentNode.insertBefore(instructionDiv, chartDiv);
    }
    
    document.getElementById('trendChartModal').classList.remove('hidden');
}

// Delete a custom metric
function deleteMetric(index) {
    const metric = customMetrics[index];
    document.getElementById('deleteMetricName').textContent = metric.name;
    document.getElementById('deleteConfirmModal').dataset.deleteIndex = index;
    document.getElementById('deleteConfirmModal').classList.remove('hidden');
}

// Modal controls
function initializeModalControls() {
    const addMetricBtn = document.getElementById('addMetricBtn');
    const exportMetricsBtn = document.getElementById('exportMetricsBtn');
    const importMetricsBtn = document.getElementById('importMetricsBtn');
    const cancelMetricBtn = document.getElementById('cancelMetricBtn');
    const addMetricModal = document.getElementById('addMetricModal');
    const addMetricForm = document.getElementById('addMetricForm');
    
    const updateValueModal = document.getElementById('updateValueModal');
    const cancelUpdateBtn = document.getElementById('cancelUpdateBtn');
    const updateValueForm = document.getElementById('updateValueForm');
    
    const trendChartModal = document.getElementById('trendChartModal');
    const closeTrendChartBtn = document.getElementById('closeTrendChartBtn');
    
    // Export Metrics Button
    if (exportMetricsBtn) {
        exportMetricsBtn.addEventListener('click', function() {
            if (customMetrics.length === 0) {
                alert('No metrics to export!');
                return;
            }
            
            const selectedProgram = localStorage.getItem('selectedProgram');
            const exportData = {
                program: selectedProgram,
                exportDate: new Date().toISOString(),
                metrics: customMetrics
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `metrics-${selectedProgram.replace(/[^a-z0-9]/gi, '_')}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            console.log('‚úÖ Metrics exported successfully');
        });
    }
    
    // Import Metrics Button
    if (importMetricsBtn) {
        importMetricsBtn.addEventListener('click', function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        
                        if (!importedData.metrics || !Array.isArray(importedData.metrics)) {
                            alert('Invalid metrics file format!');
                            return;
                        }
                        
                        const confirmMsg = `Import ${importedData.metrics.length} metrics from "${importedData.program}"?\n\nThis will ${customMetrics.length > 0 ? 'REPLACE' : 'add'} your current metrics.`;
                        
                        if (confirm(confirmMsg)) {
                            customMetrics = importedData.metrics;
                            await saveCustomMetrics();
                            renderCustomMetrics();
                            console.log('‚úÖ Metrics imported successfully');
                            alert(`‚úÖ Successfully imported ${customMetrics.length} metrics!`);
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        alert('Error importing metrics file. Please check the file format.');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        });
    }
    
    // Add/Edit Metric Modal
    if (addMetricBtn) {
        addMetricBtn.addEventListener('click', function() {
            document.getElementById('modalTitle').textContent = 'Add Custom Metric';
            document.getElementById('submitMetricBtn').textContent = 'Add Metric';
            document.getElementById('editingMetricIndex').value = '';
            addMetricForm.reset();
            addMetricModal.classList.remove('hidden');
        });
    }
    
    if (cancelMetricBtn) {
        cancelMetricBtn.addEventListener('click', function() {
            addMetricModal.classList.add('hidden');
            addMetricForm.reset();
            document.getElementById('editingMetricIndex').value = '';
        });
    }
    
    if (addMetricForm) {
        addMetricForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const editIndex = document.getElementById('editingMetricIndex').value;
            const value = parseFloat(document.getElementById('metricValue').value);
            
            const metricData = {
                name: document.getElementById('metricName').value,
                value: value,
                target: parseFloat(document.getElementById('metricTarget').value),
                targetDate: document.getElementById('metricTargetDate').value,
                unit: document.getElementById('metricUnit').value,
                lastUpdated: new Date().toISOString()
            };
            
            if (editIndex === '') {
                // Adding new metric
                metricData.history = [{
                    value: value,
                    date: new Date().toISOString()
                }];
                customMetrics.push(metricData);
            } else {
                // Editing existing metric
                const index = parseInt(editIndex);
                customMetrics[index] = {
                    ...customMetrics[index],
                    ...metricData,
                    history: customMetrics[index].history || [{
                        value: value,
                        date: new Date().toISOString()
                    }]
                };
            }
            
            await saveCustomMetrics();
            renderCustomMetrics();
            
            addMetricModal.classList.add('hidden');
            addMetricForm.reset();
            document.getElementById('editingMetricIndex').value = '';
        });
    }
    
    // Update Value Modal
    if (cancelUpdateBtn) {
        cancelUpdateBtn.addEventListener('click', function() {
            updateValueModal.classList.add('hidden');
            updateValueForm.reset();
        });
    }
    
    if (updateValueForm) {
        updateValueForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const index = parseInt(document.getElementById('updateMetricIndex').value);
            const newValue = parseFloat(document.getElementById('updateMetricValue').value);
            const dateValue = document.getElementById('updateMetricDate').value;
            const annotation = document.getElementById('updateMetricAnnotation').value.trim();
            
            console.log('üìù Updating metric at index:', index);
            console.log('üìù New value:', newValue, 'Date:', dateValue);
            console.log('üìù History before update:', customMetrics[index].history);
            
            // Add to history with user-specified date and annotation
            if (!customMetrics[index].history) {
                customMetrics[index].history = [];
            }
            
            // Convert date to ISO string at noon UTC to avoid timezone issues
            const selectedDate = new Date(dateValue + 'T12:00:00Z');
            
            const historyEntry = {
                value: newValue,
                date: selectedDate.toISOString()
            };
            
            // Add annotation if provided
            if (annotation) {
                historyEntry.annotation = annotation;
            }
            
            customMetrics[index].history.push(historyEntry);
            
            console.log('üìù History after update:', customMetrics[index].history);
            
            // Update current value
            customMetrics[index].value = newValue;
            customMetrics[index].lastUpdated = selectedDate.toISOString();
            
            await saveCustomMetrics();
            console.log('‚úÖ Metrics saved to server');
            renderCustomMetrics();
            
            updateValueModal.classList.add('hidden');
            updateValueForm.reset();
        });
    }
    
    // Trend Chart Modal
    if (closeTrendChartBtn) {
        closeTrendChartBtn.addEventListener('click', function() {
            trendChartModal.classList.add('hidden');
        });
    }
    
    // Delete Confirmation Modal
    const deleteConfirmModal = document.getElementById('deleteConfirmModal');
    const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
    const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');
    
    if (cancelDeleteBtn) {
        cancelDeleteBtn.addEventListener('click', function() {
            deleteConfirmModal.classList.add('hidden');
        });
    }
    
    if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', async function() {
            const index = parseInt(deleteConfirmModal.dataset.deleteIndex);
            console.log('Deleting metric at index:', index, 'Metric:', customMetrics[index]);
            console.log('Metrics before delete:', customMetrics.length, customMetrics);
            
            customMetrics.splice(index, 1);
            
            console.log('Metrics after delete:', customMetrics.length, customMetrics);
            
            await saveCustomMetrics();
            console.log('Metrics saved to server');
            
            renderCustomMetrics();
            console.log('Table re-rendered');
            
            deleteConfirmModal.classList.add('hidden');
        });
    }
    
    // Upload Metrics Modal
    const uploadMetricsBtn = document.getElementById('uploadMetricsBtn');
    const uploadMetricsModal = document.getElementById('uploadMetricsModal');
    const cancelUploadBtn = document.getElementById('cancelUploadBtn');
    const parseFileBtn = document.getElementById('parseFileBtn');
    const backToUploadBtn = document.getElementById('backToUploadBtn');
    const importDataBtn = document.getElementById('importDataBtn');
    const metricsFileInput = document.getElementById('metricsFileInput');
    
    let parsedFileData = null;
    
    if (uploadMetricsBtn) {
        uploadMetricsBtn.addEventListener('click', function() {
            document.getElementById('uploadStep1').classList.remove('hidden');
            document.getElementById('uploadStep2').classList.add('hidden');
            uploadMetricsModal.classList.remove('hidden');
        });
    }
    
    if (cancelUploadBtn) {
        cancelUploadBtn.addEventListener('click', function() {
            uploadMetricsModal.classList.add('hidden');
            metricsFileInput.value = '';
            parsedFileData = null;
        });
    }
    
    if (backToUploadBtn) {
        backToUploadBtn.addEventListener('click', function() {
            document.getElementById('uploadStep2').classList.add('hidden');
            document.getElementById('uploadStep1').classList.remove('hidden');
        });
    }
    
    if (parseFileBtn) {
        parseFileBtn.addEventListener('click', async function() {
            const file = metricsFileInput.files[0];
            if (!file) {
                alert('Please select a file to upload');
                return;
            }
            
            try {
                const data = await parseMetricsFile(file);
                parsedFileData = data;
                showFieldMapping(data);
                document.getElementById('uploadStep1').classList.add('hidden');
                document.getElementById('uploadStep2').classList.remove('hidden');
            } catch (error) {
                alert('Error parsing file: ' + error.message);
            }
        });
    }
    
    if (importDataBtn) {
        importDataBtn.addEventListener('click', async function() {
            const metricNameCol = document.getElementById('mapMetricName').value;
            const dateCol = document.getElementById('mapDate').value;
            const valueCol = document.getElementById('mapValue').value;
            
            if (!metricNameCol || !dateCol || !valueCol) {
                alert('Please map all required fields');
                return;
            }
            
            await importMetricsData(parsedFileData, metricNameCol, dateCol, valueCol);
            uploadMetricsModal.classList.add('hidden');
            metricsFileInput.value = '';
            parsedFileData = null;
        });
    }
}

// Parse CSV or Excel file
async function parseMetricsFile(file) {
    const fileName = file.name.toLowerCase();
    
    if (fileName.endsWith('.csv')) {
        return parseCSV(file);
    } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
        return parseExcel(file);
    } else {
        throw new Error('Unsupported file format. Please use CSV or Excel.');
    }
}

// Parse CSV file
function parseCSV(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const lines = text.split('\n').filter(line => line.trim());
            
            if (lines.length < 2) {
                reject(new Error('File must have at least a header row and one data row'));
                return;
            }
            
            const headers = lines[0].split(',').map(h => h.trim().replace(/['"]/g, ''));
            const rows = lines.slice(1).map(line => {
                const values = line.split(',').map(v => v.trim().replace(/['"]/g, ''));
                const row = {};
                headers.forEach((header, i) => {
                    row[header] = values[i] || '';
                });
                return row;
            });
            
            resolve({ headers, rows });
        };
        reader.onerror = () => reject(new Error('Error reading CSV file'));
        reader.readAsText(file);
    });
}

// Parse Excel file (simplified - uses XLSX library if available)
function parseExcel(file) {
    return new Promise((resolve, reject) => {
        if (typeof XLSX === 'undefined') {
            // Fallback: load XLSX library dynamically
            const script = document.createElement('script');
            script.src = 'https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js';
            script.onload = () => readExcelFile(file, resolve, reject);
            script.onerror = () => reject(new Error('Failed to load Excel parser library'));
            document.head.appendChild(script);
        } else {
            readExcelFile(file, resolve, reject);
        }
    });
}

function readExcelFile(file, resolve, reject) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
            
            if (jsonData.length < 2) {
                reject(new Error('Excel file must have at least a header row and one data row'));
                return;
            }
            
            const headers = jsonData[0];
            const rows = jsonData.slice(1).map(row => {
                const obj = {};
                headers.forEach((header, i) => {
                    obj[header] = row[i] !== undefined ? String(row[i]) : '';
                });
                return obj;
            });
            
            resolve({ headers, rows });
        } catch (error) {
            reject(new Error('Error parsing Excel file: ' + error.message));
        }
    };
    reader.onerror = () => reject(new Error('Error reading Excel file'));
    reader.readAsArrayBuffer(file);
}

// Show field mapping interface
function showFieldMapping(data) {
    const { headers, rows } = data;
    
    // Populate preview table
    const thead = document.getElementById('previewTableHead');
    const tbody = document.getElementById('previewTableBody');
    
    thead.innerHTML = '<tr>' + headers.map(h => `<th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">${h}</th>`).join('') + '</tr>';
    
    const previewRows = rows.slice(0, 5);
    tbody.innerHTML = previewRows.map(row => 
        '<tr>' + headers.map(h => `<td class="px-4 py-2 text-sm text-gray-900">${row[h] || ''}</td>`).join('') + '</tr>'
    ).join('');
    
    // Populate mapping dropdowns
    const mapMetricName = document.getElementById('mapMetricName');
    const mapDate = document.getElementById('mapDate');
    const mapValue = document.getElementById('mapValue');
    
    [mapMetricName, mapDate, mapValue].forEach(select => {
        select.innerHTML = '<option value="">-- Select Column --</option>' + 
            headers.map(h => `<option value="${h}">${h}</option>`).join('');
    });
    
    // Auto-detect columns based on common names
    headers.forEach(header => {
        const lower = header.toLowerCase();
        if (lower.includes('metric') || lower.includes('name')) {
            mapMetricName.value = header;
        } else if (lower.includes('date') || lower.includes('time')) {
            mapDate.value = header;
        } else if (lower.includes('value') || lower.includes('amount') || lower.includes('score')) {
            mapValue.value = header;
        }
    });
}

// Import metrics data
async function importMetricsData(data, metricNameCol, dateCol, valueCol) {
    const { rows } = data;
    let importCount = 0;
    let updateCount = 0;
    
    rows.forEach(row => {
        const metricName = row[metricNameCol];
        const dateStr = row[dateCol];
        const valueStr = row[valueCol];
        
        if (!metricName || !dateStr || !valueStr) return;
        
        const value = parseFloat(valueStr);
        if (isNaN(value)) return;
        
        // Parse date (handle various formats)
        let date;
        try {
            date = new Date(dateStr);
            if (isNaN(date.getTime())) return;
        } catch (e) {
            return;
        }
        
        // Find or create metric
        let metric = customMetrics.find(m => m.name === metricName);
        
        if (!metric) {
            // Create new metric with first data point
            metric = {
                name: metricName,
                value: value,
                target: value * 1.1, // Default target 10% higher
                targetDate: '',
                unit: '',
                lastUpdated: date.toISOString(),
                history: []
            };
            customMetrics.push(metric);
            importCount++;
        }
        
        // Add to history if not duplicate
        if (!metric.history) metric.history = [];
        
        const existingEntry = metric.history.find(h => 
            new Date(h.date).toDateString() === date.toDateString()
        );
        
        if (!existingEntry) {
            metric.history.push({
                value: value,
                date: date.toISOString()
            });
            updateCount++;
            
            // Update current value if this is the latest date
            if (new Date(metric.lastUpdated) < date) {
                metric.value = value;
                metric.lastUpdated = date.toISOString();
            }
        }
    });
    
    await saveCustomMetrics();
    renderCustomMetrics();
    
    alert(`Import complete!\n\nMetrics imported: ${importCount}\nData points added: ${updateCount}`);
}
</script>
{% endblock %}


