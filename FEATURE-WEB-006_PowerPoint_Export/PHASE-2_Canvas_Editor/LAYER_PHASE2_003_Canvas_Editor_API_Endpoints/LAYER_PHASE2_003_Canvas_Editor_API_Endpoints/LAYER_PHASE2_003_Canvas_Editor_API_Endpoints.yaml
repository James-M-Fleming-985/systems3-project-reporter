# ====================================================================================
# LAYER REQUIREMENT TEMPLATE
# ====================================================================================
# This template defines layer-level requirements that implement feature capabilities.
# Layers are the LOWEST level in the requirements hierarchy: Project→System→Feature→Layer
#
# CRITICAL: This file is typically AUTO-GENERATED by build_feature.py --init-layers
# Manual creation should follow the same structure and traceability patterns.
# ====================================================================================
# REQUIREMENTS TRACEABILITY CHAIN:
#   PROJECT Requirements (business goals)
#     ↓ decomposed into
#   SYSTEM Requirements (technical systems)
#     ↓ decomposed into
#   FEATURE Requirements (user-facing features)
#     ↓ decomposed into
#   LAYER Requirements (implementation components) ← YOU ARE HERE
# ====================================================================================
# FOLDER NAMING CONVENTION - CRITICAL FOR PYTHON IMPORTS:
#
# Format: LAYER_{layer_id_underscores}_{layer_name_underscores}
# Example: LAYER_003_001_001_YAML_XML_Reader
#
# Conversion Rules:
#   - Layer ID: LAYER-003-001-001 → LAYER_003_001_001 (hyphens to underscores)
#   - Layer Name: "YAML XML Reader" → YAML_XML_Reader (spaces to underscores)
#
# WHY THIS MATTERS:
#   - Python cannot import modules with spaces or hyphens in names
#   - ModuleNotFoundError if naming doesn't follow convention
#   - build_feature.py enforces this via standardize_layer_folder_name()
#   - No fallback logic exists - violations cause immediate build failures
#
# AUTOMATED CREATION (RECOMMENDED):
#   Command: python build_feature.py --init-layers FEATURE_REQUIREMENTS.yaml
#   Result: Auto-generated folders + YAMLs with correct naming + traceability
#
# MANUAL CREATION (NOT RECOMMENDED):
#   1. Create folder: LAYER_XXX_YYY_ZZZ_LayerName/
#   2. Copy this template to: LAYER_XXX_YYY_ZZZ_LayerName/REQ-XXX-YYY-ZZZ.yaml
#   3. Update ALL [PLACEHOLDER] values
#   4. Ensure metadata.layer_folder EXACTLY matches actual folder name
# ====================================================================================

# ====================================================================================
# METADATA - Identifies this requirement uniquely
# ====================================================================================
metadata:
  requirement_id: "REQ-PHASE2-003"
  requirement_title: "Canvas Editor API Endpoints"
  layer_id: "LAYER-PHASE2-003"
  layer_name: "Canvas Editor API Endpoints"
  layer_folder: "LAYER_PHASE2_003_Canvas_Editor_API_Endpoints"
  
  parent_feature: "FEATURE-WEB-006-PHASE-2_Canvas_Editor_PowerPoint_Slides"
  parent_feature_file: "../FEATURE-WEB-006-PHASE-2.yaml"
  
  version: "1.0.0"
  status: "Active"
  priority: "MUST HAVE"
  created_date: "2025-01-20"
  updated_date: "2025-01-20"
  owner: "Backend Team Lead"
  target_date: "2025-02-15"
  
  change_log:
    - version: "1.0.0"
      date: "2025-01-20"
      changes: "Initial version - auto-generated by build_feature.py --init-layers"
      author: "AI-derived"

# ====================================================================================
# TRACEABILITY - Shows requirement lineage
# ====================================================================================
traceability:
  parent_feature_requirements:
    - "FEAT-REQ-001: Canvas state synchronization between frontend and backend"
    - "FEAT-REQ-002: RESTful API for canvas operations"
    - "FEAT-REQ-003: Real-time canvas updates via WebSocket"
    - "FEAT-REQ-004: Canvas object CRUD operations"
  
  parent_system_requirements:
    - "SYS-REQ-WEB-001: Web-based interactive presentation system"
    - "SYS-REQ-API-003: RESTful API architecture with WebSocket support"
  
  parent_project_requirements:
    - "PRJ-REQ-002: Interactive PowerPoint-like web application"
    - "PRJ-REQ-005: Real-time collaboration capabilities"
  
  derivation_rationale: |
    This layer implements the backend API endpoints required for the Canvas Editor feature.
    It provides RESTful endpoints for canvas CRUD operations, object manipulation, and
    real-time synchronization. The layer bridges the frontend canvas editor with the
    backend storage and processing layers, enabling persistent canvas state management
    and multi-user collaboration through WebSocket connections.

# ====================================================================================
# REQUIREMENT DEFINITION - What this layer does and why
# ====================================================================================
requirement:
  title: "Canvas Editor API Endpoints"
  
  description: |
    Implements FastAPI endpoints for canvas editor operations including:
    - Canvas creation, retrieval, update, and deletion
    - Canvas object (shapes, text, images) manipulation
    - Real-time canvas state synchronization via WebSocket
    - Canvas export functionality (to PowerPoint, PDF, image formats)
    - Canvas permissions and sharing management
    - Canvas version history and undo/redo operations
  
  rationale: |
    The Canvas Editor requires a robust backend API to persist canvas states, enable
    real-time collaboration, and support export functionality. This layer provides
    the necessary endpoints to support all frontend canvas operations while ensuring
    data consistency, security, and scalability for multi-user scenarios.

# ====================================================================================
# SPECIFICATION - Technical details of what to build
# ====================================================================================
specification:
  # File/module structure
  structure:
    entry_point: "src/api/canvas/routes.py"
    modules:
      - "routes.py"        # Main FastAPI route definitions
      - "schemas.py"       # Pydantic models for request/response
      - "websocket.py"     # WebSocket handlers for real-time updates
      - "validators.py"    # Input validation logic
      - "dependencies.py"  # Dependency injection for auth, db, etc.
  
  # Main classes/functions to implement
  classes:
    - name: "CanvasRouter"
      purpose: "FastAPI router for canvas-related endpoints"
      methods:
        - name: "create_canvas"
          signature: "create_canvas(canvas: CanvasCreate, user: User = Depends(get_current_user)) -> CanvasResponse"
          purpose: "Create a new canvas with initial configuration"
          example: |
            # Example usage
            POST /api/canvas
            {
              "title": "My Presentation",
              "width": 1920,
              "height": 1080,
              "background": "#FFFFFF"
            }
        
        - name: "get_canvas"
          signature: "get_canvas(canvas_id: str, user: User = Depends(get_current_user)) -> CanvasResponse"
          purpose: "Retrieve canvas data including all objects"
          example: |
            # Example usage
            GET /api/canvas/{canvas_id}
        
        - name: "update_canvas"
          signature: "update_canvas(canvas_id: str, updates: CanvasUpdate, user: User = Depends(get_current_user)) -> CanvasResponse"
          purpose: "Update canvas properties or objects"
          example: |
            # Example usage
            PUT /api/canvas/{canvas_id}
            {
              "title": "Updated Title",
              "objects": [...]
            }
    
    - name: "CanvasWebSocketManager"
      purpose: "Manages WebSocket connections for real-time canvas updates"
      methods:
        - name: "connect"
          signature: "connect(websocket: WebSocket, canvas_id: str, user_id: str) -> None"
          purpose: "Establish WebSocket connection for canvas"
          example: |
            # WebSocket connection
            ws://localhost:8000/ws/canvas/{canvas_id}
        
        - name: "broadcast_update"
          signature: "broadcast_update(canvas_id: str, update: CanvasUpdate) -> None"
          purpose: "Send canvas updates to all connected clients"
  
  # Key technical details
  implementation_details:
    libraries: ["fastapi", "pydantic", "websockets", "python-multipart", "pillow"]
    patterns: ["Repository Pattern", "Dependency Injection", "Publisher-Subscriber"]
    error_handling:
      - error_type: "CanvasNotFoundError"
        handling: "Return 404 with descriptive message"
      - error_type: "PermissionDeniedError"
        handling: "Return 403 with permission details"
      - error_type: "ValidationError"
        handling: "Return 422 with field-specific errors"
  
  # Input/output contract
  inputs:
    - name: "canvas_create"
      type: "CanvasCreate"
      description: "Canvas creation parameters"
      example: '{"title": "New Canvas", "width": 1920, "height": 1080}'
    
    - name: "canvas_update"
      type: "CanvasUpdate"
      description: "Canvas update operations"
      example: '{"objects": [{"id": "obj1", "type": "rectangle", "x": 100, "y": 100}]}'
  
  outputs:
    - name: "canvas_response"
      type: "CanvasResponse"
      description: "Complete canvas state with metadata"
      example: '{"id": "canvas123", "title": "My Canvas", "objects": [], "created_at": "2025-01-20T10:00:00Z"}'

# ================================================================================
# ACCEPTANCE CRITERIA - How to verify this layer works correctly
# ================================================================================
acceptance_criteria:
  - criterion: "Canvas CRUD operations work correctly"
    test: "Create, read, update, and delete canvas via API endpoints"
    example: |
      # Test CRUD operations
      pytest tests/integration/test_canvas_api.py::test_canvas_crud -v
  
  - criterion: "WebSocket real-time updates function properly"
    test: "Multiple clients receive updates when canvas is modified"
    example: |
      # Test WebSocket broadcasting
      pytest tests/integration/test_canvas_websocket.py::test_broadcast_updates -v
  
  - criterion: "API response time under 200ms for read operations"
    test: "Load test canvas retrieval endpoint"
    example: |
      # Performance test
      locust -f tests/performance/canvas_api_load.py --users 100 --spawn-rate 10
  
  - criterion: "Proper authentication and authorization"
    test: "Verify only authorized users can access/modify canvas"
    example: |
      # Security test
      pytest tests/security/test_canvas_auth.py -v

# ================================================================================
# TDD IMPLEMENTATION PLAN - Step-by-step guide for implementation
# ================================================================================
week_1_task:
  title: "Build Canvas Editor API Endpoints (TDD Approach)"
  
  steps:
    - step: 1
      action: "Write failing unit tests for API schemas"
      file: "tests/unit/test_canvas_schemas.py"
      tests:
        - "test_canvas_create_schema_validation"
        - "test_canvas_update_schema_validation"
        - "test_canvas_response_serialization"
      duration: "2 hours"
    
    - step: 2
      action: "Implement Pydantic schemas"
      file: "src/api/canvas/schemas.py"
      methods:
        - "CanvasCreate(BaseModel)"
        - "CanvasUpdate(BaseModel)"
        - "CanvasResponse(BaseModel)"
      duration: "1 hour"
    
    - step: 3
      action: "Write failing integration tests for endpoints"
      file: "tests/integration/test_canvas_routes.py"
      tests:
        - "test_create_canvas_endpoint"
        - "test_get_canvas_endpoint"
        - "test_update_canvas_endpoint"
        - "test_delete_canvas_endpoint"
      duration: "3 hours"
    
    - step: 4
      action: "Implement FastAPI routes"
      file: "src/api/canvas/routes.py"
      methods:
        - "router = APIRouter(prefix='/canvas')"
        - "@router.post('/')"
        - "@router.get('/{canvas_id}')"
        - "@router.put('/{canvas_id}')"
      duration: "4 hours"
    
    - step: 5
      action: "Write WebSocket tests"
      file: "tests/integration/test_canvas_websocket.py"
      tests:
        - "test_websocket_connection"
        - "test_websocket_broadcast"
        - "test_websocket_authentication"
      duration: "2 hours"
    
    - step: 6
      action: "Implement WebSocket handlers"
      file: "src/api/canvas/websocket.py"
      improvements:
        - "Connection pooling for scalability"
        - "Message queuing for reliability"
        - "Error recovery mechanisms"
      duration: "3 hours"
  
  total_time: "15 hours"
  
  deliverable: "Fully functional Canvas Editor API with real-time WebSocket support"

# ====================================================================================
# INTEGRATION POINTS - How this layer connects to others
# ====================================================================================
integration:
  input_from:
    - layer: "LAYER-PHASE2-001"
      data_type: "HTTP requests with JSON payloads"
      interface: "FastAPI route handlers"
    
    - layer: "Authentication Layer"
      data_type: "User authentication tokens"
      interface: "Depends(get_current_user)"
  
  output_to:
    - layer: "LAYER-PHASE2-004"
      data_type: "Canvas data models"
      interface: "Canvas service layer methods"
    
    - layer: "LAYER-PHASE2-002"
      data_type: "WebSocket messages"
      interface: "WebSocket broadcast events"
  
  shared_dependencies:
    - "Canvas data models (schemas.py)"
    - "Authentication middleware"
    - "Database session management"

# ================================================================================
# TESTING STRATEGY - Different test levels for this layer
# ================================================================================
testing_strategy:
  unit_tests:
    location: "tests/unit/test_canvas_api.py"
    coverage_target: "95%"
    key_scenarios:
      - "Schema validation for all input types"
      - "Error response formatting"
      - "Permission checking logic"
  
  integration_tests:
    location: "tests/integration/test_canvas_endpoints.py"
    scenarios:
      - "Full CRUD operation flow"
      - "WebSocket connection lifecycle"
      - "Concurrent user updates"
  
  fixtures:
    location: "tests/fixtures/canvas/"
    files:
      - "sample_canvas.json"
      - "canvas_with_objects.json"
      - "invalid_canvas_data.json"

# ================================================================================
# DEPLOYMENT NOTES - How to deploy/use this layer
# ================================================================================
deployment:
  dependencies:
    - package: "fastapi"
      version: "0.104.1"
      purpose: "Web framework for API endpoints"
    
    - package: "pydantic"
      version: "2.5.0"
      purpose: "Data validation and serialization"
    
    - package: "websockets"
      version: "12.0"
      purpose: "WebSocket protocol support"
  
  configuration:
    - setting: "CANVAS_MAX_SIZE"
      value: "10MB"
      location: "config/api_settings.yaml"
    
    - setting: "WEBSOCKET_PING_INTERVAL"
      value: "30"
      location: "config/api_settings.yaml"
  
  usage_example: |
    # Example of API usage
    from fastapi import FastAPI
    from src.api.canvas.routes import router as canvas_router
    
    app = FastAPI()
    app.include_router(canvas_router, prefix="/api")
    
    # WebSocket endpoint
    from src.api.canvas.websocket import websocket_endpoint
    app.add_websocket_route("/ws/canvas/{canvas_id}", websocket_endpoint)

# ================================================================================
# CODE GENERATION CONSTRAINTS - CRITICAL for AI Code Generation Quality
# ================================================================================
# These constraints MUST be followed when AI generates implementation code
# Violations will cause runtime errors and integration failures
# ================================================================================
code_generation_constraints:
  
  # Output Format Rules - Prevents markdown wrapping
  output_format:
    - "Return ONLY raw Python code - NO explanations or commentary"
    - "NO markdown code fences (```python or ```)"
    - "First line MUST be valid Python (import statement, class definition, or function)"
    - "Last line MUST be valid Python code (NOT a closing markdown fence)"
    - "File must be directly executable without any preprocessing"
  
  # API Usage Rules - Prevents method invention
  api_usage:
    - "ONLY call methods that are explicitly defined in this layer's interface"
    - "DO NOT invent method variations, aliases, or similar names"
    - "Use EXACT method names as specified in requirements"
    - "If a method is not listed in the interface, DO NOT create or call it"
    - "Method signatures must match exactly (parameter names, types, return types)"
  
  # Import Completeness Rules - Prevents missing imports
  import_completeness:
    - "Import ALL types used in type hints (Dict, List, Optional, Tuple, Any, Union, etc.)"
    - "Import ALL third-party libraries before use"
    - "Import ALL standard library modules before use"
    - "Verify all imported names are actually used in the code"
    - "Remove unused imports to maintain clean code"
  
  # Naming Convention Rules - Ensures consistency
  naming_conventions:
    - "Primary class name MUST match the layer name or be clearly related"
    - "Use descriptive, unambiguous names for methods and variables"
    - "Follow PEP 8 naming conventions (snake_case for functions, PascalCase for classes)"
    - "Avoid generic names like 'process', 'handle', 'do' without context"
  
  # Code Quality Rules - Prevents stub/placeholder code
  quality_requirements:
    - "NO stub implementations (pass statements without logic)"
    - "NO placeholder comments like TODO, FIXME, NOT IMPLEMENTED"
    - "NO fake/mock data unless explicitly required for testing"
    - "ALL methods must have complete, working implementations"
    - "Code must be production-ready, not a prototype"
  
  # Validation Requirements - Ensures code correctness
  validation_requirements:
    - "Code MUST be syntactically valid Python 3.10+"
    - "All referenced attributes MUST exist on their objects"
    - "All method calls MUST match actual method signatures"
    - "Type hints must be accurate and complete"
    - "Code must pass basic static analysis (no obvious errors)"

# ================================================================================
# NOTES - Additional context, gotchas, or important information
# ================================================================================
notes: |
  IMPORTANT CONSIDERATIONS:
  - WebSocket connections must handle reconnection gracefully
  - Canvas size limits must be enforced to prevent DoS attacks
  - Object ordering (z-index) must be preserved across updates
  - Concurrent editing conflicts need resolution strategy
  
  DESIGN DECISIONS:
  - Using FastAPI for automatic OpenAPI documentation
  - WebSocket chosen over SSE for bidirectional communication
  - Pydantic for runtime validation and serialization
  
  FUTURE ENHANCEMENTS:
  - Canvas templates and theme support
  - Batch operations for performance optimization
  - Canvas analytics and usage tracking
  - Export queue for large canvas exports

# ================================================================================
# END OF LAYER REQUIREMENT
# ================================================================================