# ====================================================================================
# LAYER REQUIREMENT TEMPLATE
# ====================================================================================
# This template defines layer-level requirements that implement feature capabilities.
# Layers are the LOWEST level in the requirements hierarchy: Project→System→Feature→Layer
#
# CRITICAL: This file is typically AUTO-GENERATED by build_feature.py --init-layers
# Manual creation should follow the same structure and traceability patterns.
# ====================================================================================
# REQUIREMENTS TRACEABILITY CHAIN:
#   PROJECT Requirements (business goals)
#     ↓ decomposed into
#   SYSTEM Requirements (technical systems)
#     ↓ decomposed into
#   FEATURE Requirements (user-facing features)
#     ↓ decomposed into
#   LAYER Requirements (implementation components) ← YOU ARE HERE
# ====================================================================================
# FOLDER NAMING CONVENTION - CRITICAL FOR PYTHON IMPORTS:
#
# Format: LAYER_{layer_id_underscores}_{layer_name_underscores}
# Example: LAYER_003_001_001_YAML_XML_Reader
#
# Conversion Rules:
#   - Layer ID: LAYER-003-001-001 → LAYER_003_001_001 (hyphens to underscores)
#   - Layer Name: "YAML XML Reader" → YAML_XML_Reader (spaces to underscores)
#
# WHY THIS MATTERS:
#   - Python cannot import modules with spaces or hyphens in names
#   - ModuleNotFoundError if naming doesn't follow convention
#   - build_feature.py enforces this via standardize_layer_folder_name()
#   - No fallback logic exists - violations cause immediate build failures
#
# AUTOMATED CREATION (RECOMMENDED):
#   Command: python build_feature.py --init-layers FEATURE_REQUIREMENTS.yaml
#   Result: Auto-generated folders + YAMLs with correct naming + traceability
#
# MANUAL CREATION (NOT RECOMMENDED):
#   1. Create folder: LAYER_XXX_YYY_ZZZ_LayerName/
#   2. Copy this template to: LAYER_XXX_YYY_ZZZ_LayerName/REQ-XXX-YYY-ZZZ.yaml
#   3. Update ALL [PLACEHOLDER] values
#   4. Ensure metadata.layer_folder EXACTLY matches actual folder name
# ====================================================================================

# ====================================================================================
# METADATA - Identifies this requirement uniquely
# ====================================================================================
metadata:
  requirement_id: "REQ-PHASE2-002"
  requirement_title: "Image Manipulation Service"
  layer_id: "LAYER-PHASE2-002"
  layer_name: "Image Manipulation Service"
  layer_folder: "LAYER_PHASE2_002_Image_Manipulation_Service"
  
  parent_feature: "FEATURE-WEB-006-PHASE-2_Canvas_Editor_PowerPoint_Slides"
  parent_feature_file: "../FEATURE-WEB-006-PHASE-2.yaml"
  
  version: "1.0.0"
  status: "Active"
  priority: "MUST HAVE"
  created_date: "2025-01-20"
  updated_date: "2025-01-20"
  owner: "Development Team"
  target_date: "2025-02-15"
  
  change_log:
    - version: "1.0.0"
      date: "2025-01-20"
      changes: "Initial version - image manipulation service for canvas editor"
      author: "AI-derived"

# ====================================================================================
# TRACEABILITY - Shows requirement lineage
# ====================================================================================
traceability:
  parent_feature_requirements:
    - "FEAT-REQ-PHASE2-001: Support advanced image manipulation including crop, resize, rotate, and filters"
    - "FEAT-REQ-PHASE2-002: Maintain high performance with large images (up to 10MB)"
    - "FEAT-REQ-PHASE2-003: Support undo/redo for all image operations"
  
  parent_system_requirements:
    - "SYS-REQ-001: System shall provide real-time image editing capabilities"
    - "SYS-REQ-002: System shall maintain image quality during transformations"
  
  parent_project_requirements:
    - "PRJ-REQ-001: Enable users to create professional presentations with rich media"
    - "PRJ-REQ-002: Provide intuitive image editing within the canvas"
  
  derivation_rationale: |
    This layer implements the core image manipulation functionality required by the
    Canvas Editor feature. It provides a service layer that handles all image
    transformations (resize, crop, rotate, filters) while maintaining performance
    and quality. The service is designed to work with canvas operations and
    support undo/redo functionality through command pattern implementation.

# ====================================================================================
# REQUIREMENT DEFINITION - What this layer does and why
# ====================================================================================
requirement:
  title: "Image Manipulation Service"
  
  description: |
    Provides comprehensive image manipulation capabilities for the canvas editor,
    including resize, crop, rotate, flip, and filter operations. The service
    processes images efficiently using PIL/Pillow, maintains aspect ratios,
    supports various image formats (PNG, JPEG, WebP), and integrates with the
    undo/redo system. All operations are non-destructive and maintain original
    image quality where possible.
  
  rationale: |
    Users need to manipulate images directly within the canvas editor without
    switching to external tools. This service centralizes all image processing
    logic, ensuring consistent behavior, optimal performance, and seamless
    integration with the canvas rendering system. By providing a dedicated
    service layer, we enable reusability across different parts of the application.

# ====================================================================================
# SPECIFICATION - Technical details of what to build
# ====================================================================================
specification:
  # File/module structure
  structure:
    entry_point: "src/image_manipulation/image_service.py"
    modules:
      - "image_service.py"        # Main service class with manipulation methods
      - "image_processor.py"      # Core image processing logic
      - "image_filters.py"        # Filter implementations (blur, sharpen, etc.)
      - "image_transforms.py"     # Transformation operations (resize, rotate, crop)
      - "image_formats.py"        # Format conversion and optimization
      - "image_commands.py"       # Command pattern for undo/redo support
  
  # Main classes/functions to implement
  classes:
    - name: "ImageManipulationService"
      purpose: "Main service class providing image manipulation operations"
      methods:
        - name: "resize_image"
          signature: "resize_image(image: PIL.Image, width: int, height: int, maintain_aspect: bool = True) -> PIL.Image"
          purpose: "Resize image to specified dimensions"
          example: |
            # Example usage
            service = ImageManipulationService()
            resized = service.resize_image(image, 800, 600, maintain_aspect=True)
        
        - name: "crop_image"
          signature: "crop_image(image: PIL.Image, x: int, y: int, width: int, height: int) -> PIL.Image"
          purpose: "Crop image to specified rectangle"
          example: |
            cropped = service.crop_image(image, 100, 100, 400, 300)
        
        - name: "rotate_image"
          signature: "rotate_image(image: PIL.Image, angle: float, fill_color: str = 'transparent') -> PIL.Image"
          purpose: "Rotate image by specified angle"
          example: |
            rotated = service.rotate_image(image, 45.0, fill_color='white')
        
        - name: "apply_filter"
          signature: "apply_filter(image: PIL.Image, filter_type: str, intensity: float = 1.0) -> PIL.Image"
          purpose: "Apply image filter (blur, sharpen, grayscale, etc.)"
          example: |
            filtered = service.apply_filter(image, 'blur', intensity=0.5)
    
    - name: "ImageCommand"
      purpose: "Base class for undoable image operations"
      methods:
        - name: "execute"
          signature: "execute() -> PIL.Image"
          purpose: "Execute the image operation"
        
        - name: "undo"
          signature: "undo() -> PIL.Image"
          purpose: "Undo the image operation"
    
    - name: "ImageProcessor"
      purpose: "Low-level image processing utilities"
      methods:
        - name: "optimize_image"
          signature: "optimize_image(image: PIL.Image, format: str, quality: int = 85) -> bytes"
          purpose: "Optimize image for web delivery"
  
  # Key technical details
  implementation_details:
    libraries: ["Pillow", "numpy", "io", "base64"]
    patterns: ["Command Pattern", "Service Layer", "Factory Pattern"]
    error_handling:
      - error_type: "InvalidImageFormat"
        handling: "Convert to supported format or return error message"
      - error_type: "ImageTooLarge"
        handling: "Reject images over 10MB with clear error message"
      - error_type: "InvalidOperation"
        handling: "Return original image with warning"
  
  # Input/output contract
  inputs:
    - name: "image_data"
      type: "bytes | PIL.Image | str (base64)"
      description: "Image data in various formats"
      example: "data:image/png;base64,iVBORw0KGgo..."
    
    - name: "operation_params"
      type: "Dict[str, Any]"
      description: "Parameters for the image operation"
      example: "{'width': 800, 'height': 600, 'maintain_aspect': True}"
  
  outputs:
    - name: "processed_image"
      type: "PIL.Image"
      description: "Processed image object"
      example: "<PIL.Image.Image image mode=RGBA size=800x600>"
    
    - name: "image_metadata"
      type: "Dict[str, Any]"
      description: "Metadata about the processed image"
      example: "{'format': 'PNG', 'size': (800, 600), 'mode': 'RGBA'}"

# ================================================================================
# ACCEPTANCE CRITERIA - How to verify this layer works correctly
# ================================================================================
acceptance_criteria:
  - criterion: "Image resize maintains aspect ratio when requested"
    test: "Verify that resizing a 1000x500 image to 800px width results in 800x400"
    example: |
      # Example test command
      pytest tests/unit/test_image_service.py::test_resize_maintains_aspect_ratio -v
  
  - criterion: "Crop operation produces exact dimensions"
    test: "Verify cropped image has exact requested dimensions"
    example: |
      pytest tests/unit/test_image_service.py::test_crop_exact_dimensions -v
  
  - criterion: "Rotation preserves image quality"
    test: "Compare SSIM score before and after rotation"
    example: |
      pytest tests/unit/test_image_service.py::test_rotation_quality -v
  
  - criterion: "Performance requirement: Process 5MB image in under 2 seconds"
    test: "Time image operations on various file sizes"
    example: |
      pytest tests/performance/test_image_performance.py -v
  
  - criterion: "All operations support undo/redo"
    test: "Verify command pattern implementation for each operation"
    example: |
      pytest tests/unit/test_image_commands.py -v

# ================================================================================
# TDD IMPLEMENTATION PLAN - Step-by-step guide for implementation
# ================================================================================
week_1_task:
  title: "Build Image Manipulation Service (TDD Approach)"
  
  steps:
    - step: 1
      action: "Write failing unit tests (RED phase)"
      file: "tests/unit/test_image_service.py"
      tests:
        - "test_resize_image_with_aspect_ratio"
        - "test_resize_image_without_aspect_ratio"
        - "test_crop_image_valid_bounds"
        - "test_crop_image_invalid_bounds"
        - "test_rotate_image_90_degrees"
        - "test_apply_blur_filter"
      duration: "2 hours"
    
    - step: 2
      action: "Run pytest to confirm RED phase"
      command: "pytest tests/unit/test_image_service.py -v"
      expected: "All tests FAIL (as expected)"
      duration: "5 min"
    
    - step: 3
      action: "Implement ImageManipulationService (GREEN phase)"
      file: "src/image_manipulation/image_service.py"
      methods:
        - "resize_image() → PIL.Image"
        - "crop_image() → PIL.Image"
        - "rotate_image() → PIL.Image"
        - "apply_filter() → PIL.Image"
      duration: "4 hours"
    
    - step: 4
      action: "Run pytest to confirm GREEN phase"
      command: "pytest tests/unit/test_image_service.py -v"
      expected: "All tests PASS"
      duration: "10 min"
    
    - step: 5
      action: "Refactor for code quality (REFACTOR phase)"
      improvements:
        - "Extract common validation logic"
        - "Add comprehensive error handling"
        - "Optimize memory usage for large images"
      duration: "2 hours"
    
    - step: 6
      action: "Integration test with canvas layer"
      file: "tests/integration/test_image_canvas_integration.py"
      duration: "1 hour"
  
  total_time: "9 hours 15 minutes"
  
  deliverable: "Complete image manipulation service with resize, crop, rotate, and filter capabilities"

# ====================================================================================
# INTEGRATION POINTS - How this layer connects to others
# ====================================================================================
integration:
  input_from:
    - layer: "LAYER-PHASE2-001"
      data_type: "Image file upload or canvas selection"
      interface: "receive_image_data(data: bytes, metadata: Dict)"
    
    - layer: "LAYER-PHASE2-003"
      data_type: "Manipulation commands from UI"
      interface: "process_command(command: ImageCommand)"
  
  output_to:
    - layer: "LAYER-PHASE2-001"
      data_type: "Processed image for canvas rendering"
      interface: "return_processed_image(image: PIL.Image, metadata: Dict)"
    
    - layer: "LAYER-PHASE2-004"
      data_type: "Image data for storage"
      interface: "prepare_for_storage(image: PIL.Image, format: str)"
  
  shared_dependencies:
    - "Common image format validators"
    - "Performance monitoring utilities"
    - "Error handling middleware"

# ================================================================================
# TESTING STRATEGY - Different test levels for this layer
# ================================================================================
testing_strategy:
  unit_tests:
    location: "tests/unit/test_image_service.py"
    coverage_target: "95%"
    key_scenarios:
      - "Resize with various aspect ratios"
      - "Crop with edge cases"
      - "Rotate at multiple angles"
      - "Filter application and intensity"
      - "Format conversion"
      - "Error handling"
  
  integration_tests:
    location: "tests/integration/test_image_integration.py"
    scenarios:
      - "Upload and process workflow"
      - "Canvas selection to manipulation"
      - "Undo/redo chain"
      - "Performance under load"
  
  fixtures:
    location: "tests/fixtures/images/"
    files:
      - "sample_portrait.jpg"
      - "sample_landscape.png"
      - "sample_transparent.png"
      - "sample_large.jpg"
      - "sample_small.gif"

# ================================================================================
# DEPLOYMENT NOTES - How to deploy/use this layer
# ================================================================================
deployment:
  dependencies:
    - package: "Pillow"
      version: ">=10.0.0"
      purpose: "Core image processing library"
    
    - package: "numpy"
      version: ">=1.24.0"
      purpose: "Numerical operations for filters"
  
  configuration:
    - setting: "MAX_IMAGE_SIZE"
      value: "10485760"  # 10MB in bytes
      location: "config/image_service.yaml"
    
    - setting: "ALLOWED_FORMATS"
      value: "['PNG', 'JPEG', 'JPG', 'GIF', 'WebP']"
      location: "config/image_service.yaml"
    
    - setting: "DEFAULT_QUALITY"
      value: "85"
      location: "config/image_service.yaml"
  
  usage_example: |
    # Example of how to use this layer
    from src.image_manipulation import ImageManipulationService
    from PIL import Image
    
    service = ImageManipulationService()
    
    # Load image
    image = Image.open('path/to/image.jpg')
    
    # Resize image
    resized = service.resize_image(image, 800, 600)
    
    # Apply filter
    filtered = service.apply_filter(resized, 'sharpen', intensity=0.7)
    
    # Save result
    filtered.save('output.png')

# ================================================================================
# CODE GENERATION CONSTRAINTS - CRITICAL for AI Code Generation Quality
# ================================================================================
# These constraints MUST be followed when AI generates implementation code
# Violations will cause runtime errors and integration failures
# ================================================================================
code_generation_constraints:
  
  # Output Format Rules - Prevents markdown wrapping
  output_format:
    - "Return ONLY raw Python code - NO explanations or commentary"
    - "NO markdown code fences (```python or ```)"
    - "First line MUST be valid Python (import statement, class definition, or function)"
    - "Last line MUST be valid Python code (NOT a closing markdown fence)"
    - "File must be directly executable without any preprocessing"
  
  # API Usage Rules - Prevents method invention
  api_usage:
    - "ONLY call methods that are explicitly defined in this layer's interface"
    - "DO NOT invent method variations, aliases, or similar names"
    - "Use EXACT method names as specified in requirements"
    - "If a method is not listed in the interface, DO NOT create or call it"
    - "Method signatures must match exactly (parameter names, types, return types)"
  
  # Import Completeness Rules - Prevents missing imports
  import_completeness:
    - "Import ALL types used in type hints (Dict, List, Optional, Tuple, Any, Union, etc.)"
    - "Import ALL third-party libraries before use"
    - "Import ALL standard library modules before use"
    - "Verify all imported names are actually used in the code"
    - "Remove unused imports to maintain clean code"
  
  # Naming Convention Rules - Ensures consistency
  naming_conventions:
    - "Primary class name MUST match the layer name or be clearly related"
    - "Use descriptive, unambiguous names for methods and variables"
    - "Follow PEP 8 naming conventions (snake_case for functions, PascalCase for classes)"
    - "Avoid generic names like 'process', 'handle', 'do' without context"
  
  # Code Quality Rules - Prevents stub/placeholder code
  quality_requirements:
    - "NO stub implementations (pass statements without logic)"
    - "NO placeholder comments like TODO, FIXME, NOT IMPLEMENTED"
    - "NO fake/mock data unless explicitly required for testing"
    - "ALL methods must have complete, working implementations"
    - "Code must be production-ready, not a prototype"
  
  # Validation Requirements - Ensures code correctness
  validation_requirements:
    - "Code MUST be syntactically valid Python 3.10+"
    - "All referenced attributes MUST exist on their objects"
    - "All method calls MUST match actual method signatures"
    - "Type hints must be accurate and complete"
    - "Code must pass basic static analysis (no obvious errors)"

# ================================================================================
# NOTES - Additional context, gotchas, or important information
# ================================================================================
notes: |
  IMPORTANT CONSIDERATIONS:
  - Image processing can be memory-intensive; implement streaming for large files
  - Always preserve EXIF data when possible (orientation, metadata)
  - WebP format provides best compression for web delivery
  - Consider implementing progressive JPEG encoding for large images
  
  DESIGN DECISIONS:
  - Using Pillow over OpenCV for better format support and simpler API
  - Command pattern chosen to enable clean undo/redo implementation
  - Service layer pattern provides clean separation from UI concerns
  
  FUTURE ENHANCEMENTS:
  - Add AI-powered filters (background removal, enhancement)
  - Implement batch processing for multiple images
  - Add support for animated GIF manipulation
  - Implement smart cropping with face/object detection

# ================================================================================
# END OF LAYER REQUIREMENT
# ================================================================================